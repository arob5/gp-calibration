---
title: "EKI_tests"
author: "Andrew Roberts"
date: '2023-11-28'
output: html_document
---

```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(lhs)
library(hetGP)
library(mlegp)
library(ggplot2)
library(viridis)
library(parallel)
library(gridExtra)
library(data.table)
library(BayesianTools)

base_dir <- "." # Should be EKI dir
helper_func_dir <- file.path(base_dir, "..", "vsem_calibration_tests")

source(file.path(helper_func_dir, "numerical_experiment_functions.r"))
source(file.path(helper_func_dir, "mcmc_calibration_functions.r"))
source(file.path(helper_func_dir, "gp_emulator_functions.r"))
source(file.path(helper_func_dir, "gp_mcmc_functions.r"))
source(file.path(helper_func_dir, "sequential_design_optimization.r"))
```

# Linear Gaussian Model

```{r}
seed <- 10
set.seed(seed)

# Linear Gaussian Model Setup. 
data_seed <- 23
d <- 2
N_obs <- 100
# freqs <- c(1, 2) 
# G <- cbind(sin(2*pi*freqs[1]*seq(1, N_obs)/N_obs), sin(2*pi*freqs[2]*seq(1, N_obs)/N_obs))

G <- t(t(chol(matrix(c(1, 0.7, 0.7, 1), nrow=2))) %*% matrix(rnorm(N_obs*d), nrow=d, ncol=N_obs))

Sig_eps <- 0.4 * diag(rep(1,N_obs))
Sig0 <- matrix(c(1, 0, 0, 1), nrow=2)
# Sig0 <- matrix(c(1, 1, 1, 4), nrow=2)
mu0 <- matrix(rep(0, d), ncol=1)
theta_true <- mu0 + t(chol(Sig0)) %*% matrix(rnorm(d), ncol=1)

linear_Gaussian_info <- gen_linear_Gaussian_data(G, mu0, Sig0, Sig_eps, theta_true=theta_true)
mu_true <- linear_Gaussian_info$theta_true
Sig_true <- linear_Gaussian_info$Sig
y_true <- linear_Gaussian_info$y_true
y <- linear_Gaussian_info$y

forward_model <- function(theta_vals) {
  # Each column of `theta_vals` is a parameter value. 
  G %*% theta_vals
}
```


```{r}
# Plot linear Gaussian data. 

sim_data <- as.data.frame(y)
sim_data$ref <- y_true
sim_data$time <- 1:N_obs
linear_Gaussian_data_plt <- ggplot(sim_data) + geom_point(mapping=aes(x=time, y=y)) + 
                              geom_line(mapping=aes(x=time, y=ref), color="red") + 
                              xlab("t") + ylab("output") + ggtitle("Ground Truth and Observed Data")

plot(linear_Gaussian_data_plt)
```



```{r}
# Multiscale algorithm test. 

time_step_vals <- 10^(-3) # c(10^(-3), 10^(-4))
sigma_vals <- 10^(-2) # c(10^(-2), 10^(10^-4))
delta_vals <- 10^(-4) # c(10^(-4), 10^(-8))
N_ensemble <- 8
N_itr <- 5000

samp_results <- data.table(time_step = numeric(), 
                           sigma = numeric(), 
                           delta = numeric(), 
                           param_idx = integer(), 
                           samp = numeric())  
err_results <- data.frame(time_step = numeric(), 
                          sigma = numeric(), 
                          delta = numeric(), 
                          KL_div = numeric()) 

# Plan: build two data.frames with columns as above. Will be easier to compute the metrics 
#       directly from the `run_multiscale_inversion()` output. Alternatively, I could do 
#       KL divergence between the true and approx distribution. This will only be relevant 
#       for the linear model case. 

for(time_step in time_step_vals) {
  for(sigma in sigma_vals) {
   for(delta in delta_vals) {
     # Samples from multiscale algorithm. 
     u_samp <- run_multiscale_inversion(forward_model, y, Sig_eps, m0, Sig0, N_itr, time_step,
                                        sigma, delta, N_ensemble)
     
     # Append samples to data.table. 
     samp_results <- rbindlist(list(samp_results, data.table(time_step=time_step, 
                                                             sigma=sigma, delta=delta, 
                                                             param_idx=1, samp=u_samp[,1])), use.names=TRUE)
     samp_results <- rbindlist(list(samp_results, data.table(time_step=time_step, 
                                                             sigma=sigma, delta=delta, 
                                                             param_idx=2, samp=u_samp[,2])), use.names=TRUE)
     
     # Compute error metrics. 
     errs <- compute_running_err(u_samp, mu_true, Sig_true)
     samp_results <- rbindlist(list(err_results, data.table(time_step=time_step, 
                                    sigma=sigma, delta=delta, KL_div=errs$KL)), use.names=TRUE)
                                    
   }
  }
}


```

```{r}
# plot(u_samp[1000:5000,1], u_samp[1000:5000,2])
plot(u_samp[1000:N_itr,1], u_samp[1000:N_itr,2])
```

```{r}
# Exact samples
N_samp_exact <- 25000
L_Sig_true <- t(chol(Sig_true))
samp_exact <- t(drop(mu_true) + L_Sig_true %*% matrix(rnorm(N_samp_exact*d), nrow=d, ncol=N_samp_exact))

plot(samp_exact[,1], samp_exact[,2])
```






