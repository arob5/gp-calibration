---
title: "EKI_tests"
author: "Andrew Roberts"
date: '2023-11-28'
output: html_document
---

```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(lhs)
library(hetGP)
library(mlegp)
library(ggplot2)
library(viridis)
library(parallel)
library(gridExtra)
library(data.table)
library(BayesianTools)

base_dir <- "." # Should be EKI dir
helper_func_dir <- file.path(base_dir, "..", "vsem_calibration_tests")
plot_dir <- file.path(base_dir, "../../", "typed-notes", "multiscale_paper_figures")

source(file.path(helper_func_dir, "numerical_experiment_functions.r"))
source(file.path(helper_func_dir, "mcmc_calibration_functions.r"))
source(file.path(helper_func_dir, "gp_emulator_functions.r"))
source(file.path(helper_func_dir, "gp_mcmc_functions.r"))
source(file.path(helper_func_dir, "sequential_design_optimization.r"))
```

# Linear Gaussian Model

```{r}
seed <- 10
set.seed(seed)

# Linear Gaussian Model Setup. 
data_seed <- 23
d <- 2
N_obs <- 100
# freqs <- c(1, 2) 
# G <- cbind(sin(2*pi*freqs[1]*seq(1, N_obs)/N_obs), sin(2*pi*freqs[2]*seq(1, N_obs)/N_obs))

G <- t(t(chol(matrix(c(1, 0.7, 0.7, 1), nrow=2))) %*% matrix(rnorm(N_obs*d), nrow=d, ncol=N_obs))

Sig_eps <- 0.4 * diag(rep(1,N_obs))
Sig0 <- matrix(c(1, 0, 0, 1), nrow=2)
# Sig0 <- matrix(c(1, 1, 1, 4), nrow=2)
mu0 <- matrix(rep(0, d), ncol=1)
mu_ground_truth <- mu0 + t(chol(Sig0)) %*% matrix(rnorm(d), ncol=1)

linear_Gaussian_info <- gen_linear_Gaussian_data(G, mu0, Sig0, Sig_eps, theta_true=theta_true)
mu_true <- linear_Gaussian_info$theta_true
Sig_true <- linear_Gaussian_info$Sig
y_true <- linear_Gaussian_info$y_true
y <- linear_Gaussian_info$y

forward_model <- function(theta_vals) {
  # Each column of `theta_vals` is a parameter value. 
  G %*% theta_vals
}
```


```{r}
# Plot linear Gaussian data. 

sim_data <- as.data.frame(y)
sim_data$ref <- y_true
sim_data$time <- 1:N_obs
linear_Gaussian_data_plt <- ggplot(sim_data) + geom_point(mapping=aes(x=time, y=y)) + 
                              geom_line(mapping=aes(x=time, y=ref), color="red") + 
                              xlab("t") + ylab("output") + ggtitle("Ground Truth and Observed Data")

plot(linear_Gaussian_data_plt)
```



```{r}
# Multiscale algorithm test. 

time_step_vals <- c(10^(-3), 10^(-4))
sigma_vals <- c(10^(-2), 10^(-4))
delta_vals <- c(10^(-4), 10^(-8))
N_ensemble <- 8
N_itr <- 5000

init_cond <- mu0 + t(chol(Sig0)) %*% matrix(rnorm(d), ncol=1)

samp_results <- data.table(time_step = numeric(), 
                           sigma = numeric(), 
                           delta = numeric(), 
                           param_idx = integer(), 
                           samp = numeric())  
err_results <- data.frame(time_step = numeric(), 
                          sigma = numeric(), 
                          delta = numeric(), 
                          itr = integer(),
                          KL_div = numeric()) 

for(time_step in time_step_vals) {
  for(sigma in sigma_vals) {
   for(delta in delta_vals) {
     # Samples from multiscale algorithm. 
     u_samp <- run_multiscale_inversion(forward_model, y, Sig_eps, m0, Sig0, N_itr, time_step,
                                        sigma, delta, N_ensemble, theta_init=init_cond)
     
     # Append samples to data.table. 
     samp_results <- rbindlist(list(samp_results, data.table(time_step=time_step, 
                                                             sigma=sigma, delta=delta, 
                                                             param_idx=1, samp=u_samp[,1])), use.names=TRUE)
     samp_results <- rbindlist(list(samp_results, data.table(time_step=time_step, 
                                                             sigma=sigma, delta=delta, 
                                                             param_idx=2, samp=u_samp[,2])), use.names=TRUE)
     
     # Compute error metrics. 
     errs <- compute_running_err(u_samp, mu_true, Sig_true)
     err_results <- rbindlist(list(err_results, data.table(time_step=time_step, sigma=sigma, 
                                    delta=delta, itr=1:nrow(u_samp), KL_div=errs$KL)), use.names=TRUE)
                                    
   }
  }
}


```

```{r}
# Adaptive RWMH 
rwmh_samp <- rwmh_Gaussian(forward_model, y, Sig_eps, m0, Sig0, theta_init=NULL, N_mcmc=N_itr, 
                           adapt_frequency=500, accept_rate_target=0.24, proposal_scale_decay=0.7,
                           proposal_scale_multiplier=1, Cov_prop_init_diag=NULL, adapt_init_threshold=3)
```

```{r}
# MCMC diagnostics. 
plot(1:N_itr, rwmh_samp$theta[,1], type="l")
plot(1:N_itr, rwmh_samp$theta[,2], type="l")
plot(rwmh_samp$theta[,1], rwmh_samp$theta[,2])
```

```{r} 
err_results[, comb := paste(time_step, sigma, delta, sep=", ")] 
mcmc_errs <- compute_running_err(rwmh_samp$theta[2:N_itr,], mu_true, Sig_true)
mcmc_errs_df <- data.table(itr=seq_along(mcmc_errs$KL), KL_div=mcmc_errs$KL)

itr_threshold <- 100

# KL Divergence. 
ggplot(err_results[itr>itr_threshold], aes(itr, KL_div, color=comb)) + # color=interaction(time_step, sigma, delta, sep=':'))) +
    geom_path() + 
    geom_line(aes(itr, KL_div), mcmc_errs_df[itr>itr_threshold], color="black") + 
    scale_y_continuous(trans="log10") + 
    scale_x_continuous(trans="log10") + 
    labs(color="Delta, sigma, delta") + 
    xlab("Iteration") + 
    ylab("KL Divergence") + 
    theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
          panel.background=element_blank(), axis.line=element_line(colour="black"), 
          text=element_text(size=20))

ggsave(file.path(plot_dir, "lin_Gaus_KL.png"), width=10, height=7)
```


```{r}
burn_in_end <- 1000
multiscale_samp_scatter <- samp_results[(time_step==1e-3) & (sigma==1e-4) & (delta==1e-4)]
multiscale_samp_scatter <- multiscale_samp_scatter[(burn_in_end+1):nrow(multiscale_samp_scatter)]
rwmh_samp_scatter <- rwmh_samp$theta[(burn_in_end+1):nrow(rwmh_samp$theta),]

rng_x <- range(c(rwmh_samp_scatter[,1], multiscale_samp_scatter[param_idx==1, samp]))
rng_y <- range(c(rwmh_samp_scatter[,2], multiscale_samp_scatter[param_idx==2, samp]))

contour_grid_x <- seq(rng_x[1], rng_x[2], length.out=50)
contour_grid_y <- seq(rng_y[1], rng_y[2], length.out=50)
contour_grid <- cbind(contour_grid_x, contour_grid_y)



```




```{r}
# plot(u_samp[1000:5000,1], u_samp[1000:5000,2])
plot(u_samp[1000:N_itr,1], u_samp[1000:N_itr,2])
```

```{r}
# Exact samples
N_samp_exact <- 25000
L_Sig_true <- t(chol(Sig_true))
samp_exact <- t(drop(mu_true) + L_Sig_true %*% matrix(rnorm(N_samp_exact*d), nrow=d, ncol=N_samp_exact))

plot(samp_exact[,1], samp_exact[,2])
```






