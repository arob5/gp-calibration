#
# init_emulator.r
# Part 3 in the inverse problem simulation study workflow. This script:
# (1) loads inverse problem data saved to file by `inv_prob_setup.r`.
# (2) Fits one or more Gaussian process (GP) emulator models for each replicate 
#     design of a specified initial design tag. A llikEmulator object is saved 
#     for fit model.
# (3) Generate GP and llikEmulator predictions at validation points, and compute
#     various metrics summarizing emulator fit.
# (4) the information from steps (1) through (4) is all saved to file, for use 
#     in the subsequent parts of the simulation study. Each emulator type
#     is assigned an emulator tag, and all outputs for that emulator type
#     will be saved within 
#     `output/gp_inv_prob/vsem/init_emulator/<emulator_tag>`. Sub-directories
#     will be created within this directory of the form 
#     `<design_tag>/<seed>` where <design_tag> and <seed> uniquely specify the 
#     initial design replicate that was used in fitting the emulator. 
#
# This file is intended to be called from `run_init_emulator.sh`, which is 
# in turn called by `run_init_emulator_reps.r`. These files call this script
# one design_id at a time, and also handle the log files generated by the 
# remote jobs. This file is set up to be able to process multiple design 
# IDs if needed, but currently the files that run this file only pass it 
# one ID at a time.
#
# Andrew Roberts
#

library(ggplot2)
library(data.table)
library(assertthat)
library(docopt)

# -----------------------------------------------------------------------------
# docopt string for parsing command line arguments.  
# -----------------------------------------------------------------------------

"Usage:
  test_docopt.r [options]
  test_docopt.r (-h | --help)

Options:
  -h --help                                 Show this screen.
  --experiment_tag=<experiment_tag>         The experiment tag.
  --design_tag=<design_tag>                 The initial design tag.
  --design_id=<design_id>                   The design ID to use.
" -> doc

# ------------------------------------------------------------------------------
# Settings 
# ------------------------------------------------------------------------------

# Read command line arguments.
cmd_args <- docopt(doc)
experiment_tag <- cmd_args$experiment_tag
design_tag <- cmd_args$design_tag
design_ids <- cmd_args$design_id


print("--------------------Running `init_emulator.r` --------------------")
print(paste0("Experiment tag: ", experiment_tag))
print(paste0("Design tag: ", design_tag))
print(paste0("Design IDs: ", paste(design_ids, sep=", ")))

# ------------------------------------------------------------------------------
# Setup 
# ------------------------------------------------------------------------------

# Filepath definitions.
base_dir <- file.path("/projectnb", "dietzelab", "arober", "gp-calibration")
src_dir <- file.path(base_dir, "src")
experiment_dir <- file.path(base_dir, "output", "gp_inv_prob", experiment_tag)
setup_dir <- file.path(experiment_dir, "inv_prob_setup")
design_dir <- file.path(experiment_dir, "init_design", design_tag)
base_out_dir <- file.path(experiment_dir, "init_emulator", design_tag)

# Source required files.
source(file.path(src_dir, "general_helper_functions.r"))
source(file.path(src_dir, "inv_prob_test_functions.r"))
source(file.path(src_dir, "statistical_helper_functions.r"))
source(file.path(src_dir, "plotting_helper_functions.r"))
source(file.path(src_dir, "seq_design.r"))
source(file.path(src_dir, "gp_helper_functions.r"))
source(file.path(src_dir, "gpWrapper.r"))
source(file.path(src_dir, "llikEmulator.r"))
source(file.path(src_dir, "mcmc_helper_functions.r"))
source(file.path(src_dir, "gp_mcmc_functions.r"))
source(file.path(src_dir, "basis_function_emulation.r"))

# Load R project. 
renv::load(base_dir)
print(".libPaths()")
print(.libPaths())
renv::status()

# Load inverse problem setup information.
inv_prob <- readRDS(file.path(setup_dir, "inv_prob_list.rds"))
test_info_prior <- readRDS(file.path(setup_dir, "test_info_prior.rds"))
test_info_post <- readRDS(file.path(setup_dir, "test_info_post.rds"))

# Log-likelihood bounds.
llik_bounds <- inv_prob$llik_obj$get_llik_bounds()

# Settings list.
settings <- list(experiment_tag=experiment_tag, design_tag=design_tag)

# ------------------------------------------------------------------------------
# Specify emulator models to fit:
# Create a list of emulator models. Each element should itself be a list, which 
# has the element "fit_em", a function which fits the emulator model. 
# The function must accept the argument `design_info` and 
# return a llikEmulator object. Should also have an element "fwd_em" which is 
# a logical value that specifies whether the emulator is a forward model emulator
# or a log-likelihood emulator. The names of the outer list are used as the 
# emulator tags, which are used to create the output directories. 
# Note that the functions make use of the global variables `inv_prob` and 
# `llik_bounds`.
# ------------------------------------------------------------------------------

em_list <- list()

# Log-likelihood emulator. Gaussian kernel, quadratic mean function.
em_list$em_llik_quad_mean$fwd_em <- FALSE
em_list$em_llik_quad_mean$fit_em <- function(design_info) {
 
  # Fit GP for log-likelihood.
  gp_obj <- gpWrapperKerGP(design_info$input, matrix(design_info$llik, ncol=1), 
                           scale_input=TRUE, normalize_output=TRUE)
  gp_obj$set_gp_prior("Gaussian", "quadratic", include_noise=FALSE)
  gp_obj$fit(multistart=10, trace=TRUE)

  # Instantiate and save log-likelihood emulator object.
  em_llik <- llikEmulatorGP("em_llik", gp_obj, default_conditional=FALSE, 
                            default_normalize=TRUE, lik_par=inv_prob$sig2_model, 
                            llik_bounds=llik_bounds)

  return(em_llik)
}

# Forward model emulator. PCA basis approximation to output space.
em_list$em_fwd_basis$fwd_em <- TRUE
em_list$em_fwd_basis$fit_em <- function(design_info) {
  
  # Run PCA on model outputs.
  pca_list <- pca(design_info$fwd) 

  # Threshold the number of basis vectors. 
  variance_threshold <- 0.975
  pca_list_trunc <- truncate_pca_basis(pca_list, variance_threshold)
  r <- length(pca_list_trunc$sqrt_val)
  print(paste0("Number of eigenvectors retained: ", r))
  
  # Fit independent GPs.
  W <- project_orthog_scalar(design_info$fwd, pca_list_trunc$vec, 
                             pca_list_trunc$mean)
  gp_w <- gpWrapperKerGP(design_info$input, W, scale_input=TRUE,
                         normalize_output=TRUE)
  gp_w$set_gp_prior("Gaussian", "quadratic", include_noise=FALSE)
  gp_w$fit(multistart=10)
  
  # Construct multi-output GP. Using heuristic approach of fixing the noise
  # variance in the basis function model for G(u) based on the sum of the 
  # excluded eigenvalues.
  dim_obs <- ncol(pca_list$vec)
  if(r < dim_obs) {
    noise_var <- sum(pca_list$sqrt_val[(r+1):dim_obs]^2)
  } else {
    noise_var <- sqrt(.Machine$double.eps)
  }
  
  gp_g <- gpWrapperSum(gp_w, pca_list_trunc$vec, shift=pca_list_trunc$mean, 
                       sig2=noise_var)

  # Instantiate log-likelihood emulator with multi-output GP emulator for 
  # forward model.
  llik_em <- llikEmulatorGPFwdGauss("em_fwd", gp_g, y_obs=inv_prob$y, 
                                    Cov=inv_prob$sig2_model, 
                                    default_conditional=FALSE, 
                                    default_normalize=TRUE,
                                    par_names=inv_prob$par_names)
  
  return(llik_em)
}


# ------------------------------------------------------------------------------
# Define function that computes emulator predictions at test points and 
# emulator error metrics. Different functions are defined for forward model
# vs. llik emulators, primarily due to the fact that computing predictions
# for 
# ------------------------------------------------------------------------------

test_llik_em <- function(em_llik, out_dir) {
  print("-----> Emulator predictions at test points")
  llik_pred_list_prior <- em_llik$predict(test_info_prior$input,
                                          return_mean=TRUE,
                                          return_var=TRUE)
  llik_pred_list_post <- em_llik$predict(test_info_post$input,
                                         return_mean=TRUE,
                                         return_var=TRUE)
  
  saveRDS(llik_pred_list_prior, file=file.path(out_dir, "llik_pred_list_prior.rds"))
  saveRDS(llik_pred_list_post, file=file.path(out_dir, "llik_pred_list_post.rds"))
}

#
# OLD
# 

# test_llik_em <- function(em_llik, out_dir, fwd_em) {
#   
#   print("-----> Emulator predictions at test points")
#   # This section is not dependent on whether the emulator is a forward model 
#   # or log-likelihood emulator.
#   em_pred_list_prior <- em_llik$predict_emulator(test_info_prior$input, 
#                                                  return_cov=TRUE,
#                                                  return_output_cov=TRUE)
#   em_pred_list_post <- em_llik$predict_emulator(test_info_post$input,
#                                                 return_cov=TRUE,
#                                                 return_output_cov=TRUE)
#   
#   saveRDS(em_pred_list_prior, file=file.path(out_dir, "em_pred_list_prior.rds"))
#   saveRDS(em_pred_list_post, file=file.path(out_dir, "em_pred_list_post.rds"))
#   
#   print("-----> llikEmulator error measures")
#   err_types <- c("mse", "wmse", "mae", "wmae")
#   em_llik_errs_prior <- em_llik$calc_lik_approx_pw_err(llik_true=test_info_prior$llik, 
#                                                        input=test_info_prior$input,
#                                                        err_type=err_types, 
#                                                        em_pred_list=em_pred_list_prior,
#                                                        return_type="data.table")
#   
#   em_llik_errs_post <- em_llik$calc_lik_approx_pw_err(llik_true=test_info_post$llik, 
#                                                       input=test_info_post$input,
#                                                       err_type=err_types, 
#                                                       em_pred_list=em_pred_list_post,
#                                                       return_type="data.table")
#   
#   saveRDS(em_llik_errs_prior, file=file.path(out_dir, "em_llik_errs_prior.rds"))
#   saveRDS(em_llik_errs_post, file=file.path(out_dir, "em_llik_errs_post.rds"))
#   
#   # At present, this code will cause errors when the emulator_model is of class
#   # gpWrapperSum. 
#   if(!fwd_em) {
#     print("-----> GP emulator error measures")
#     # This section differs based on whether the emulator is a forward model 
#     # or log-likelihood emulator, since the validation data will be different 
#     # in the two cases.
#     if(fwd_em) {
#       Y_new_prior <- test_info_prior$fwd
#       Y_new_post <- test_info_post$fwd
#     } else {
#       Y_new_prior <- matrix(test_info_prior$llik, ncol=1)
#       Y_new_post <- matrix(test_info_post$llik, ncol=1)
#     }
#     
#     gp_pw_err_types <- c("mae", "mse", "crps", "log_score")
#     gp_agg_err_types <- c("mah", "log_score")
#     
#     gp_pw_errs_prior <- em_llik$emulator_model$calc_pred_multi_func(gp_pw_err_types, 
#                                                                     type="pw", 
#                                                                     pred_list=em_pred_list_prior, 
#                                                                     Y_new=Y_new_prior)
#     gp_pw_errs_post <- em_llik$emulator_model$calc_pred_multi_func(gp_pw_err_types, 
#                                                                    type="pw", 
#                                                                    pred_list=em_pred_list_post, 
#                                                                    Y_new=Y_new_post)
#     gp_agg_errs_prior <- em_llik$emulator_model$calc_pred_multi_func(gp_agg_err_types, 
#                                                                      type="agg", 
#                                                                      pred_list=em_pred_list_prior, 
#                                                                      Y_new=Y_new_prior)
#     gp_agg_errs_post <- em_llik$emulator_model$calc_pred_multi_func(gp_agg_err_types, 
#                                                                     type="agg", 
#                                                                     pred_list=em_pred_list_post, 
#                                                                     Y_new=Y_new_post)
#     
#     saveRDS(gp_pw_errs_prior, file=file.path(out_dir, "gp_pw_errs_prior.rds"))
#     saveRDS(gp_pw_errs_post, file=file.path(out_dir, "gp_pw_errs_post.rds"))
#     saveRDS(gp_agg_errs_prior, file=file.path(out_dir, "gp_agg_errs_prior.rds"))
#     saveRDS(gp_agg_errs_post, file=file.path(out_dir, "gp_agg_errs_post.rds"))
#   } else {
#     message("Not computing GP emulator metrics for forward model emulator.")
#   }
# }


# ------------------------------------------------------------------------------
# Fit and test emulators, and save results to file.
# ------------------------------------------------------------------------------

print("-------------- Fitting emulators --------------")

em_tags <- names(em_list)

for(id in design_ids) {
  print(paste0("-----> Design ID: ", id))
  design_path <- file.path(design_dir, paste0(id, ".rds"))
  print(paste0("Loading design: ", design_path))
  design_info <- readRDS(design_path)
  
  for(tag in em_tags) {
    
    # Create output directory.
    print(paste0("Emulator tag: ", tag))
    out_dir <- file.path(base_out_dir, id, tag)
    print(paste0("Creating output directory: ", out_dir))
    dir.create(out_dir, recursive=TRUE)
    
    # Fit and save emulator.
    em_llik <- em_list[[tag]]$fit_em(design_info)
    saveRDS(em_llik, file=file.path(out_dir, "em_llik.rds"))
    
    # Compute emulator predictions at test points and save to file.
    test_llik_em(em_llik, out_dir)
  }
}

