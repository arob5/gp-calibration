---
title: "One-Dimensional Input Example for Basic Visualization"
author: "Andrew Roberts"
date: '2024-05-12'
output: html_document
---

```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)

# TODO: 
#    - Add a quantile approximation. 
#    - Estimate observation variance. 
#    - Exponentiate the integrated variance acquisitions if possible; o/w make clear I'm plotting the log. 
#    - Improve llik emulator GP model (consider using Vehtari method of integrating out trend coefs). 
#    - Include model discrepancy to make the data generation process differ from the 
#      likelihood so that we can obtain a more realistic log-likelihood surface. 
#      Options: different likelihood variance, set fixed parameters to values that are 
#               not equal to the ground truth, add a deterministic term to the foward  
#               model. 
#   - gpWrapper: clean up default hyperparameter setting (move to helper functions). And also set 
#                other hyperparameters (e.g., offset for quadratic kernel). 
#   - For additive kernel, decompose to understand what the quadratic and Gaussian pieces look like 
#     (see Duvenaud thesis). 
#
# A nice visual example: 
#    seed_inv_prob <- 2562
#    seed_init_design <- 1643
#    N_obs <- 1
#    N_design <- 3L
#    design_method <- "LHS"
#
# An example where the quadratic+Gaussian emulator points up:  
#    seed_inv_prob <- 2562
#    seed_init_design <- 1643
#    N_obs <- 3
#    N_design <- 3L
#    design_method <- "LHS"

library(lhs)
library(kde1d)
library(ggplot2)
library(viridis)
library(parallel)
library(gridExtra)
library(data.table)

base_dir <- file.path("/projectnb", "dietzelab", "arober", "gp-calibration")
src_dir <- file.path(base_dir, "src")
output_dir <- file.path(base_dir, "output", "gp_post_approx_paper", "test_1d_vis2")

source(file.path(src_dir, "gp_helper_functions.r"))
source(file.path(src_dir, "gpWrapper.r"))
source(file.path(src_dir, "inv_prob_test_functions.r"))
source(file.path(src_dir, "general_helper_functions.r"))
source(file.path(src_dir, "statistical_helper_functions.r"))
source(file.path(src_dir, "plotting_helper_functions.r"))
source(file.path(src_dir, "llikEmulator.r"))
source(file.path(src_dir, "gp_emulator_functions.r"))
source(file.path(src_dir, "mcmc_helper_functions.r"))
source(file.path(src_dir, "sim_study_functions.r"))
source(file.path(src_dir, "mcmc_calibration_functions.r"))
source(file.path(src_dir, "seq_design.r"))
source(file.path(src_dir, "seq_design_gp.r"))
source(file.path(src_dir, "seq_design_for_post_approx.r"))
source(file.path(src_dir, "gp_mcmc_functions.r"))

save_output <- FALSE

# Plot settings applied to all plots. 
design_pt_size <- 4
line_thickness <- 1.5
design_color <- "red"
xlim <- c(-10, 10)
ylim <- c(0.0777, 0.4)

# Random number generator seeds. 
seed_inv_prob <- 2562
seed_init_design <- 16431

# Settings for approximate simulation from sample-based approximate posterior. 
# Increasing these values increases the fidelity of the approximation. 
N_monte_carlo_sb <- 100000L

# Settings for noisy MCMC. 
N_mcmc <- 50000
burn_in_start <- N_mcmc/2

# Design point settings. 
N_design <- 3L
design_method <- "LHS"

# Test/grid point settings (for plotting).
N_grid <- 201

# Settings for confidence intervals displayed in plots. 
interval_method <- "pm_std_dev"
N_std_dev <- 1.64
```

# Summary of Inverse Problem 

```{r}
# Inverse problem setup. 
inv_prob <- get_vsem_test_1d_vis()
par_prior <- inv_prob$par_prior
llik_obj_exact <- inv_prob$llik_obj
default_conditional <- llik_obj_exact$default_conditional
default_normalize <- llik_obj_exact$default_normalize
```

## Prior Distribution
```{r}
print(inv_prob$par_info)

prior_plots <- plot_prior_samp(par_prior)
for(plt in prior_plots) plot(plt)
```

## Likelihood
```{r}
print(llik_obj_exact$lik_description)
print(paste0("Likelihood variance ground truth: ", inv_prob$sig2_true))
print(paste0("Likelihood variance model: ", llik_obj_exact$get_lik_par()[1]))
```

## Model Driver
```{r}
driver_plt <- ggplot(data.frame(t=inv_prob$time_points,PAR=inv_prob$driver)) + 
                     geom_point(aes(x=t,y=PAR)) + 
                     ggtitle("Model Driver (PAR)") + 
                     xlab("Day") + ylab("PAR")

plot(driver_plt)
```

## Ground truth observable vs. observations
```{r}
lai_idx <- which(get_vsem_output_names() == "LAI")

plot_fwd_model_output(fwd_true=inv_prob$y_true, 
                      output_true=inv_prob$model_output_true[,,lai_idx], 
                      fwd_obs=inv_prob$y, xlab="Months", ylab="LAI",
                      title="Forward Model and Observation")
```



```{r}
set.seed(seed_init_design)

# Generate design and test points.
design_inputs <- matrix(c(1.57, 3.0, 4.479, 7.45), ncol=1, 
                        dimnames=list(NULL, inv_prob$par_names))
N_design <- nrow(design_inputs)
design_info <- get_init_design_list(inv_prob, design_method, N_design=N_design,
                                    inputs=design_inputs)

# Grid of test points for plotting and emulator evaluation. The final set of test 
# points will be the union of the test grid with the design points (ensuring the 
# design points are a subset of the test points avoids certain misleading features 
# in the plots that can occur where only some design points are included in the 
# test set). 
grid_method <- "tensor_product_grid"
u_grid <- get_batch_design(grid_method, N_grid, prior_params=inv_prob$par_prior)
u_grid <- sort(union(drop(u_grid), drop(design_info$input)))
N_grid <- length(u_grid)
u_grid <- matrix(u_grid, ncol=1, dimnames=list(NULL, inv_prob$par_names))
test_info <- get_init_design_list(inv_prob, grid_method, N_grid, 
                                  prior_params=inv_prob$par_prior, 
                                  inputs=u_grid)

# Plot true unnormalized posterior density. 
plot(test_info$input, test_info$fwd, type="l", 
     main="True forward model evaluations", xlab="u", ylab="G(u)")
plot(test_info$input, test_info$llik, type="l", 
     main="True log-likelihood", xlab="u", ylab="density")
plot(test_info$input, exp(test_info$llik), type="l", 
     main="True likelihood", xlab="u", ylab="density")
```

```{r}
# Fit Log-likelihood emulator.
em_llik_gp <- gpWrapperKerGP(design_info$input, matrix(design_info$llik, ncol=1), 
                             scale_input=TRUE, normalize_output=TRUE)
em_llik_gp$set_gp_prior("Gaussian", "constant", include_noise=FALSE)
em_llik_gp$fit(multistart=10, trace=TRUE)
em_llik_gp$summarize()
em_llik <- llikEmulatorGP("em_llik", em_llik_gp, lik_par=inv_prob$sig2_model, 
                          use_fixed_lik_par=TRUE, 
                          default_conditional=default_conditional,
                          default_normalize=default_normalize)
em_pred_llik <- em_llik$predict_emulator(test_info$input, return_cov=TRUE)
```


```{r}
# Fit forward model emulator.
em_fwd_gp <- gpWrapperKerGP(design_info$input, design_info$fwd, 
                             scale_input=TRUE, normalize_output=TRUE)
em_fwd_gp$set_gp_prior("Gaussian", "constant", include_noise=FALSE)
em_fwd_gp$fit(multistart=10, trace=TRUE)
em_fwd_gp$summarize()
em_fwd <- llikEmulatorGPFwdGaussDiag("em_fwd", em_fwd_gp, inv_prob$y, 
                                     sig2=inv_prob$sig2_model, 
                                     default_conditional=default_conditional, 
                                     default_normalize=default_normalize, 
                                     use_fixed_lik_par=TRUE, 
                                     par_names=inv_prob$par_names)
em_pred_fwd <- em_fwd$predict_emulator(test_info$input, return_cov=TRUE)
```

```{r}
# Truncating the log-likelihood predictive distribution.

# Compute truncated Gaussian moments.
sig2 <- em_llik$get_lik_par()
upper_bound <- -0.5 * log(2*pi*sig2)

em_pred_llik_trunc <- em_pred_llik
em_pred_llik_trunc$mean <- etruncnorm(a=-Inf, b=upper_bound, 
                                      mean=em_pred_llik$mean, 
                                      sd=sqrt(em_pred_llik$var))

em_pred_llik_trunc$lower <- qtruncnorm(p=0.05, a=-Inf, b=upper_bound, 
                                       mean=em_pred_llik$mean, 
                                       sd=sqrt(em_pred_llik$var))
em_pred_llik_trunc$upper <- qtruncnorm(p=0.95, a=-Inf, b=upper_bound, 
                                       mean=em_pred_llik$mean, 
                                       sd=sqrt(em_pred_llik$var))

# llik distribution: truncated Gaussian.
plot_pred_1d_helper(drop(test_info$input), pred_mean=em_pred_llik_trunc$mean,
                    CI_lower=em_pred_llik_trunc$lower, 
                    CI_upper=em_pred_llik_trunc$upper, y_new=test_info$llik, 
                    X_design=drop(design_info$input), y_design=design_info$llik,
                    design_color=design_color, design_pt_size=design_pt_size) 

```

```{r}
#
# Emulator Distribution plots.  
#

# (1): Plot the underlying GP emulator predictive distributions.  
plt_gp_dist_llik <- em_llik$emulator_model$plot_pred_1d(test_info$input, include_interval=TRUE,
                                                        interval_method=interval_method, 
                                                        N_std_dev=N_std_dev,
                                                        pred_list=em_pred_llik, ylab="L(u)",
                                                        Y_new=matrix(test_info$llik, ncol=1),
                                                        line_thickness=line_thickness,
                                                        design_color=design_color, 
                                                        design_pt_size=design_pt_size, 
                                                        xlab="u", plot_title="GP predictions [llik]")[[1]]
plt_gp_dist_fwd <- em_fwd$emulator_model$plot_pred_1d(test_info$input, include_interval=TRUE,
                                                      interval_method=interval_method, 
                                                      N_std_dev=N_std_dev,
                                                      pred_list=em_pred_fwd, ylab="G(u)",
                                                      Y_new=matrix(test_info$fwd, ncol=1),
                                                      line_thickness=line_thickness,
                                                      design_color=design_color, 
                                                      design_pt_size=design_pt_size, 
                                                      xlab="u", plot_title="GP predictions [fwd]")[[1]]

plot(plt_gp_dist_llik)
plot(plt_gp_dist_fwd)

```

```{r}
# (2): Plot the log-likelihood emulator predictive distributions. 
plt_llik_dist_llik <- em_llik$plot_pred_1d(test_info$input, em_pred_list=em_pred_llik,
                                           plot_type="llik", include_interval=TRUE,
                                           interval_method=interval_method, N_std_dev=N_std_dev,
                                           true_llik=test_info$llik, CI_prob=CI_prob,
                                           line_thickness=line_thickness,
                                           design_color=design_color, 
                                           design_pt_size=design_pt_size,
                                           xlab="u", ylab="L(u)",
                                           plot_title="log-likelihood predictions [llik]")

plt_llik_dist_fwd <- em_fwd$plot_pred_1d(test_info$input, em_pred_list=em_pred_fwd,
                                         plot_type="llik", include_interval=TRUE,  
                                         interval_method=interval_method, N_std_dev=N_std_dev,
                                         true_llik=test_info$llik, CI_prob=CI_prob, ylab="L(u)",
                                         design_color=design_color, design_pt_size=design_pt_size,
                                         xlab="u", plot_title="log-likelihood predictions [fwd]")

plot(plt_llik_dist_llik)
plot(plt_llik_dist_fwd)
```

```{r}
# - Change GP prior for llik emulator to avoid getting a mean function that is increasing 
# at the right boundary.
# - Try re-plotting and simply cut off the y-axis at a certain level.
#
#

# (3): Plot the likelihood emulator predictive distributions. 
plt_lik_dist_llik <- em_llik$plot_pred_1d(test_info$input, em_pred_list=em_pred_llik,
                                          plot_type="lik", include_interval=FALSE, 
                                          true_llik=test_info$llik, CI_prob=CI_prob,
                                          line_thickness=line_thickness, 
                                          log_scale=FALSE, design_color=design_color, 
                                          design_pt_size=design_pt_size, 
                                          plot_title="likelihood predictions [llik]")


# plt_lik_dist_llik <- em_llik$plot_pred_1d(test_info$input, em_pred_list=em_pred_llik,
#                                           plot_type="lik", log_scale=TRUE,
#                                           include_interval=TRUE, 
#                                           interval_method=interval_method, N_std_dev=N_std_dev,
#                                           true_llik=test_info$llik, CI_prob=CI_prob,
#                                           line_thickness=line_thickness,
#                                           design_color=design_color, design_pt_size=design_pt_size, 
#                                           ylab="exp L(u)", xlab="u", 
#                                           plot_title="likelihood predictions [llik]")

# TODO: why does this throw an error when using "CI"?
plt_lik_dist_fwd <- em_fwd$plot_pred_1d(test_info$input, em_pred_list=em_pred_fwd, 
                                        plot_type="lik", log_scale=FALSE, 
                                        include_interval=TRUE, 
                                        interval_method=interval_method,
                                        N_std_dev=N_std_dev,
                                        true_llik=test_info$llik,
                                        line_thickness=line_thickness,
                                        design_color=design_color, 
                                        xlab="u", 
                                        plot_title="likelihood predictions [fwd]")

plot(plt_lik_dist_llik)
plot(plt_lik_dist_fwd)

```

```{r}
# Truncated log-normal predictive distribution for likelihood.

lik_pred_trunc <- list()

ln_list <- convert_Gaussian_to_LN(mean_Gaussian=em_pred_llik$mean, 
                                  var_Gaussian=em_pred_llik$var, log_scale=TRUE)
z <- drop((upper_bound - em_pred_llik$mean) / sqrt(em_pred_llik$var))
lik_pred_trunc$mean <- exp(ln_list$log_mean + 
                             log(pnorm(z-sqrt(em_pred_llik$var))) - 
                             log(pnorm(z)))

plot_pred_1d_helper(drop(test_info$input), pred_mean=lik_pred_trunc$mean,
                    y_new=exp(test_info$llik), 
                    X_design=drop(design_info$input), 
                    y_design=exp(design_info$llik),
                    design_color=design_color, design_pt_size=design_pt_size)


```


```{r}
#
# Plot formatting and saving. 
#

# Align axes: log-likelihood. 
lims_llik <- get_common_lims(plt_gp_dist_llik, plt_llik_dist_llik, plt_llik_dist_fwd)

# Align axes: likelihood. 
lims_lik <- get_common_lims(plt_lik_dist_llik, plt_lik_dist_fwd)

# GP Emulator plots. 
plt_gp_dist_llik <- ggformat_journal(plt_gp_dist_llik, xlim=lims_llik$xlim, ylim=lims_llik$ylim)
plt_gp_dist_fwd <- ggformat_journal(plt_gp_dist_fwd, xlim=lims_llik$xlim)
plot(plt_gp_dist_llik)
plot(plt_gp_dist_fwd)
if(save_output) {
  ggsave(file.path(output_dir, "gp_dist_llikem.png"), plt_gp_dist_llik)
  ggsave(file.path(output_dir, "gp_dist_fwdem.png"), plt_gp_dist_fwd)
}

# Log-likelihood plots. 
plt_llik_dist_llik <- ggformat_journal(plt_llik_dist_llik, xlim=lims_llik$xlim, ylim=lims_llik$ylim)
plt_llik_dist_fwd <- ggformat_journal(plt_llik_dist_fwd, xlim=lims_llik$xlim, ylim=lims_llik$ylim)
plot(plt_llik_dist_llik)
plot(plt_llik_dist_fwd)
if(save_output) {
  ggsave(file.path(output_dir, "llik_dist_llikem.png"), plt_llik_dist_llik)
  ggsave(file.path(output_dir, "llik_dist_fwdem.png"), plt_llik_dist_fwd)
}

# Likelihood plots. 
plt_lik_dist_llik <- ggformat_journal(plt_lik_dist_llik, xlim=lims_lik$xlim, ylim=lims_lik$ylim)
plt_lik_dist_fwd <- ggformat_journal(plt_lik_dist_fwd, xlim=lims_lik$xlim, ylim=lims_lik$ylim)
plot(plt_lik_dist_llik)
plot(plt_lik_dist_fwd)
if(save_output) {
  ggsave(file.path(output_dir, "lik_dist_llikem.png"), plt_lik_dist_llik)
  ggsave(file.path(output_dir, "lik_dist_fwdem.png"), plt_lik_dist_fwd)
}
```


```{r}
#
# Compute (approximately) normalized exact posterior. 
#

dx <- abs(test_info$input[2] - test_info$input[1])
norm_cst_exact <- int_trap(exp(test_info$llik + test_info$lprior), dx)
test_info$post <- exp(test_info$llik + test_info$lprior) / norm_cst_exact
design_info$post <- exp(design_info$llik + design_info$lprior) / norm_cst_exact

# Store approximated normalizing constants. 
norm_cst_list <- list(exact=norm_cst_exact)
```


```{r}
#
# Comparison of different posterior approximations. 
#

# Convenience functions for normalization. 
approx_norm_cst <- function(lik, dx) {
  int_trap(lik*exp(test_info$lprior), dx)
}

normalize_lik <- function(lik, norm_cst) {
  lik*exp(test_info$lprior) / norm_cst
}

# Log-likelihood emulation. 
post_approx_llik <- em_llik$calc_lik_approx_comparison(test_info$input, approx_types=c("mean", "marginal"), 
                                                       emulator_pred_list=emulator_pred_llik)

norm_cst_llik <- apply(post_approx_llik, 2, function(x) approx_norm_cst(x,dx))
approx_names_llik <- colnames(post_approx_llik)
post_approx_llik <- sapply(1:ncol(post_approx_llik), function(j) normalize_lik(post_approx_llik[,j], norm_cst_llik[j]))
colnames(post_approx_llik) <- approx_names_llik
norm_cst_list$llik <- norm_cst_llik
post_approx_llik_plt <- plot_curves_1d_helper(test_info$input, post_approx_llik, y_new=test_info$post,
                                              X_design=design_info$input, y_design=design_info$post,
                                              plot_title="Posterior Approximations [llik]",
                                              line_thickness=line_thickness, design_color=design_color,
                                              design_pt_size=design_pt_size, xlab="u",  ylab="pi(u)") %>%
                                              ggformat_journal(legend_position="none")
plot(post_approx_llik_plt)

# Forward model emulation. 
post_approx_fwd <- em_fwd$calc_lik_approx_comparison(test_info$input, approx_types=c("mean", "marginal"), 
                                                     emulator_pred_list=emulator_pred_fwd)
norm_cst_fwd <- apply(post_approx_fwd, 2, function(x) approx_norm_cst(x,dx))
approx_names_fwd <- colnames(post_approx_fwd)
post_approx_fwd <- sapply(1:ncol(post_approx_fwd), function(j) normalize_lik(post_approx_fwd[,j], norm_cst_fwd[j]))
colnames(post_approx_fwd) <- approx_names_fwd
norm_cst_list$fwd <- norm_cst_fwd
post_approx_fwd_plt <- plot_curves_1d_helper(test_info$input, post_approx_fwd, y_new=test_info$post,
                                             X_design=design_info$input, y_design=design_info$post,
                                             plot_title="Posterior Approximations [fwd]",
                                             line_thickness=line_thickness, design_color=design_color,
                                             design_pt_size=design_pt_size, xlab="u", 
                                             ylab="pi(u)") %>% ggformat_journal(legend_position="none")
plot(post_approx_fwd_plt)
```

```{r}
# Estimate the sample-based (sb) GP-approximated posterior. We consider this as 
# the "true" Bayesian solution in some sense, to which the other approximations can be compared. 
dens_sb_llik <- estimate_sample_based_density_1d_grid(em_llik, par_prior_params, test_info$input, 
                                                      N_monte_carlo=N_monte_carlo_sb)
dens_sb_fwd <- estimate_sample_based_density_1d_grid(em_fwd, par_prior_params, test_info$input, 
                                                     N_monte_carlo=N_monte_carlo_sb)

post_approx_llik <- cbind(post_approx_llik, `sample`=dens_sb_llik)
post_approx_fwd <- cbind(post_approx_fwd, `sample`=dens_sb_fwd)
```


```{r}
# MCWMH approaches. 

# Initial condition for all MCMC algorithms. 
mcmc_par_init <- sample_prior_theta(inv_prob$par_prior)

#
# Log-likelihood emulator. 
#

# MCWMH-Ind. 
mcmh_nocov_llik_list <- mcmc_gp_noisy(em_llik, inv_prob$par_prior, N_itr=N_mcmc, mode="MCMH", 
                                      use_gp_cov=FALSE, par_init=mcmc_par_init)
samp_dt <- format_mcmc_output(mcmh_nocov_llik_list$samp, test_label="nocov-llik")

# MCWMH-Joint. 
mcmh_cov_llik_list <- mcmc_gp_noisy(em_llik, inv_prob$par_prior, N_itr=N_mcmc, mode="MCMH", 
                                    use_gp_cov=TRUE, par_init=mcmc_par_init)
samp_dt <- append_mcmc_output(samp_dt, mcmh_cov_llik_list$samp, test_label="cov-llik")

#
# Forward model emulator. 
#

# MCWMH-Ind. 
mcmh_nocov_fwd_list <- mcmc_gp_noisy(em_fwd, inv_prob$par_prior, N_itr=N_mcmc, mode="MCMH", 
                                     use_gp_cov=FALSE, par_init=mcmc_par_init)
samp_dt <- append_mcmc_output(samp_dt, mcmh_nocov_fwd_list$samp, test_label="nocov-fwd")

# MCWMH-Joint. 
mcmh_cov_fwd_list <- mcmc_gp_noisy(em_fwd, inv_prob$par_prior, N_itr=N_mcmc, mode="MCMH", 
                                   use_gp_cov=TRUE, par_init=mcmc_par_init)
samp_dt <- append_mcmc_output(samp_dt, mcmh_cov_fwd_list$samp, test_label="cov-fwd")

```


```{r}
# MCMC diagnostics.

trace_plots <- get_trace_plots(samp_dt, burn_in_start=burn_in_start) 
for(plt in trace_plots) plot(plt) 

get_hist_plot_comparisons(samp_dt, test_label_baseline="nocov-llik", 
                          param_types="par", burn_in_start=burn_in_start)
```

```{r}

#
# Produce kernel density approximations of posterior using MCMC samples. 
# 


#
# Log-likelihood emulator. 
#

# MCWMH-Ind. 
kde_fit_mcwmh_ind_llik <- kde1d(select_mcmc_samp(samp_dt, burn_in_start=burn_in_start, 
                                                 test_labels="nocov-llik", param_types="par")$sample, 
                                xmin=prior_support[1], xmax=prior_support[2], deg=2, mult=1)
post_approx_llik <- cbind(post_approx_llik, `mcwmh-ind`=dkde1d(test_info$input, kde_fit_mcwmh_ind_llik))

# MCWMH-Joint. 
kde_fit_mcwmh_joint_llik <- kde1d(select_mcmc_samp(samp_dt, burn_in_start=burn_in_start, 
                                                   test_labels="cov-llik", param_types="par")$sample,
                                  xmin=prior_support[1], xmax=prior_support[2], deg=2, mult=1)
post_approx_llik <- cbind(post_approx_llik, `mcwmh-joint`=dkde1d(test_info$input, kde_fit_mcwmh_joint_llik))

#
# Forward model emulator. 
#

# MCWMH-Ind. 
kde_fit_mcwmh_ind_fwd <- kde1d(select_mcmc_samp(samp_dt, burn_in_start=burn_in_start, 
                                                test_labels="nocov-fwd", param_types="par")$sample,
                               xmin=prior_support[1], xmax=prior_support[2], deg=2, mult=1)
post_approx_fwd <- cbind(post_approx_fwd, `mcwmh-ind`=dkde1d(test_info$input, kde_fit_mcwmh_ind_fwd))

# MCWMH-Joint. 
kde_fit_mcwmh_joint_fwd <- kde1d(select_mcmc_samp(samp_dt, burn_in_start=burn_in_start, 
                                                  test_labels="cov-fwd", param_types="par")$sample,
                                 xmin=prior_support[1], xmax=prior_support[2], deg=2, mult=1)
post_approx_fwd <- cbind(post_approx_fwd, `mcwmh-joint`=dkde1d(test_info$input, kde_fit_mcwmh_joint_fwd))
```


```{r}
#
# Plot: comparison of posterior approximations. 
#

# The kernel density estimates can produce some outlier points at the edges of the domain. We 
# trim off the first and last grid point to avoid this.
N_trim <- 3L
start_idx <- N_trim+1L
stop_idx <- N_grid-N_trim
post_approx_llik_trim <- post_approx_llik[start_idx:stop_idx,]
post_approx_fwd_trim <- post_approx_fwd[start_idx:stop_idx,]
test_input_trim <- test_info$input[start_idx:stop_idx,]
post_trim <- test_info$post[start_idx:stop_idx]

# Log-likelihood emulator. 
post_approx_llik_plt <- plot_curves_1d_helper(test_input_trim, post_approx_llik_trim, y_new=post_trim,
                                              X_design=design_info$input, y_design=design_info$post,
                                              plot_title="Posterior Approximations [llik]",
                                              line_thickness=line_thickness, design_color=design_color,
                                              design_pt_size=design_pt_size, xlab="u",  ylab="pi(u)")
                                              

# Forward model emulator. 
post_approx_fwd_plt <- plot_curves_1d_helper(test_input_trim, post_approx_fwd_trim, y_new=post_trim,
                                             X_design=design_info$input, y_design=design_info$post,
                                             plot_title="Posterior Approximations [llik]",
                                             line_thickness=line_thickness, design_color=design_color,
                                             design_pt_size=design_pt_size, xlab="u",  ylab="pi(u)")

# Align axis limits. 
lims_post_trim <- get_common_lims(post_approx_llik_plt, post_approx_fwd_plt)
post_approx_llik_plt <- post_approx_llik_plt %>% 
                        ggformat_journal(legend_position="bottom", legend.text=element_text(size=20), 
                                         xlim=lims_post_trim$xlim, ylim=lims_post_trim$ylim)
post_approx_fwd_plt <- post_approx_fwd_plt %>% 
                       ggformat_journal(legend_position="bottom", legend.text=element_text(size=20), 
                                        xlim=lims_post_trim$xlim, ylim=lims_post_trim$ylim)


plot(post_approx_llik_plt)
plot(post_approx_fwd_plt)
ggsave(file.path(output_dir, "post_approx_llikem.png"), post_approx_llik_plt)
ggsave(file.path(output_dir, "post_approx_fwdem.png"), post_approx_fwd_plt)

```


```{r}
# Print normalizing constant estimates. 
print("Estimated normalizing constants:")
print(norm_cst_list)
```


# Part 2: Sequential Design 
```{r}
# We consider two classifications of the acquisitions here: 
#    (1) pointwise (pw) vs. integrated (int)
#        The pw acquisition functions only depend on a single input, while the 
#        integrated acquisition functions are a function of the entire input space.
#    (2) Classifying by their "target": gp vs. post.
#        The gp acqusition functions are defined with respect to the underlying GP 
#        emulator, while the post acquisition functions directly target the 
#        likelihood or unnormalized posterior density. 

llik_em_list <- list(llik=em_llik, fwd=em_fwd)

# Compute pointwise acquisitions. 
acq_funcs_pw <- c("llik_neg_var_gp", "llik_neg_entropy_gp", "llik_neg_var_lik")
df_acq_types <- data.frame(color=c("max-var", "max-ent", "max-var"), 
                           linetype=c("gp", "gp", "lik"))
acq_pw_list <- compare_acq_funcs_by_model(test_info$input, acq_funcs_pw, llik_em_list)
scale_acq <- function(x) scale_inputs(x, target_bounds=c(1,2))
get_min_idx_acq <- function(x) apply(x, 2, which.min)
get_opt_val_acq <- function(x) apply(x, 2, min)
acq_pw_list <- lapply(acq_pw_list, scale_acq)
opt_list_idx_pw <- lapply(acq_pw_list, get_min_idx_acq)
opt_list_val_pw <- lapply(acq_pw_list, get_opt_val_acq)

df_acq_types_llik <- df_acq_types
df_acq_types_llik$u <- test_info$input[opt_list_idx_pw$llik,]
df_acq_types_llik$val <- opt_list_val_pw$llik

df_acq_types_fwd <- df_acq_types
df_acq_types_fwd$u <- test_info$input[opt_list_idx_pw$fwd,]
df_acq_types_fwd$val <- opt_list_val_pw$fwd

# Plot pointwise acquisitions. 
acq_pw_plt_llik <- plot_curves_1d_helper(test_info$input, acq_pw_list$llik, 
                                         plot_title="pointwise acq [llik]",
                                         df_by=df_acq_types_llik, line_thickness=line_thickness, 
                                         design_color=design_color, design_pt_size=design_pt_size, 
                                         xlab="u", ylab="acq") + 
                                         geom_vline(xintercept=drop(design_info$input), 
                                                    linetype="dashed", color=design_color) + 
                                         geom_point(aes(x=u, y=val, color=color, shape=linetype), 
                                                    df_acq_types_llik, shape=15, size=design_pt_size)
  
acq_pw_plt_fwd<- plot_curves_1d_helper(test_info$input, acq_pw_list$fwd, plot_title="pointwise acq [fwd]",
                                       df_by=df_acq_types_fwd,
                                       line_thickness=line_thickness, design_color=design_color,
                                       design_pt_size=design_pt_size, xlab="u", ylab="acq") + 
                                       geom_vline(xintercept=drop(design_info$input), 
                                                  linetype="dashed", color=design_color) + 
                                       geom_point(aes(x=u, y=val, color=color, shape=linetype), 
                                                  df_acq_types_fwd, shape=15, size=design_pt_size)


acq_pw_plt_llik <- acq_pw_plt_llik %>% ggformat_journal(legend_position="bottom",
                                                        legend.text=element_text(size=20))
acq_pw_plt_fwd <- acq_pw_plt_fwd %>% ggformat_journal(legend_position="bottom",
                                                      legend.text=element_text(size=20))

plot(acq_pw_plt_llik)
plot(acq_pw_plt_fwd)

ggsave(file.path(output_dir, "acq_pw_llik.png"), acq_pw_plt_llik)
ggsave(file.path(output_dir, "acq_pw_fwd.png"), acq_pw_plt_fwd)

```

```{r}
# Integrated criteria. 

# Define integrated acqusition functions to compare. 
acq_funcs_int <- c("llik_IVAR_grid_gp", "llik_IENT_grid_gp", "llik_IEVAR_grid")
df_acq_types_int <- data.frame(color=c("int-var", "int-ent", "int-var"), 
                               linetype=c("gp", "gp", "lik"))

# Compute acquisition values. 
acq_int_list <- compare_acq_funcs_by_model(test_info$input, acq_funcs_int, llik_em_list, 
                                           grid_points=test_info$input, plugin=TRUE)
acq_int_list <- lapply(acq_int_list, scale_acq)

# Minimize acquisitions over grid. 
opt_list_idx_int <- lapply(acq_int_list, get_min_idx_acq)
opt_list_val_int <- lapply(acq_int_list, get_opt_val_acq)

df_acq_types_int_llik <- df_acq_types_int
df_acq_types_int_llik$u <- test_info$input[opt_list_idx_int$llik,]
df_acq_types_int_llik$val <- opt_list_val_int$llik

df_acq_types_int_fwd <- df_acq_types_int
df_acq_types_int_fwd$u <- test_info$input[opt_list_idx_int$fwd,]
df_acq_types_int_fwd$val <- opt_list_val_int$fwd

acq_int_plt_llik <- plot_curves_1d_helper(test_info$input, acq_int_list$llik, df_by=df_acq_types_int_llik,
                                          plot_title="Integrated acq [llik]",
                                          line_thickness=line_thickness, design_color=design_color,
                                          design_pt_size=design_pt_size, xlab="u", ylab="acq") + 
                                          geom_vline(xintercept=drop(design_info$input), 
                                                     linetype="dashed", color=design_color) + 
                                          geom_point(aes(x=u, y=val, color=color, shape=linetype), 
                                                     df_acq_types_int_llik, shape=15, size=design_pt_size)

# Forward model. 
acq_int_plt_fwd <- plot_curves_1d_helper(test_info$input, acq_int_list$fwd, df_by=df_acq_types_int_fwd,
                                         plot_title="Integrated acq [fwd]",
                                         line_thickness=line_thickness, design_color=design_color,
                                         design_pt_size=design_pt_size, xlab="u", ylab="acq") + 
                                         geom_vline(xintercept=drop(design_info$input), 
                                                    linetype="dashed", color=design_color) + 
                                         geom_point(aes(x=u, y=val, color=color, shape=linetype), 
                                                    df_acq_types_int_fwd, shape=15, size=design_pt_size)

acq_int_plt_llik <- acq_int_plt_llik %>% ggformat_journal(legend_position="bottom",
                                                          legend.text=element_text(size=20))
acq_int_plt_fwd <- acq_int_plt_fwd %>% ggformat_journal(legend_position="bottom",
                                                        legend.text=element_text(size=20))


plot(acq_int_plt_llik)
plot(acq_int_plt_fwd)

ggsave(file.path(output_dir, "acq_int_llik.png"), acq_int_plt_llik)
ggsave(file.path(output_dir, "acq_int_fwd.png"), acq_int_plt_fwd)

# TODO:
#    - When implementing these methods and the acquisition functions that call these methods, 
#      need to think about the case when there are multiple underlying GPs. 
```









