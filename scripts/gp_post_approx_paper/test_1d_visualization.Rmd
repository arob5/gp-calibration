---
title: "One-Dimensional Input Example for Basic Visualization"
author: "Andrew Roberts"
date: '2024-05-12'
output: html_document
---

```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)

# TODO: 
#    - Add a quantile approximation. 
#    - Estimate observation variance. 
#    - Improve llik emulator GP model (consider using Vehtari method of integrating out trend coefs). 
#    - Include model discrepancy to make the data generation process differ from the 
#      likelihood so that we can obtain a more realistic log-likelihood surface. 
#      Options: different likelihood variance, set fixed parameters to values that are 
#               not equal to the ground truth, add a deterministic term to the foward  
#               model. 
#   - gpWrapper: clean up default hyperparameter setting (move to helper functions). And also set 
#                other hyperparameters (e.g., offset for quadratic kernel). 
#   - For additive kernel, decompose to understand what the quadratic and Gaussian pieces look like 
#     (see Duvenaud thesis). 
#
# A nice visual example: 
#    seed_inv_prob <- 2562
#    seed_init_design <- 1643
#    N_obs <- 1
#    N_design <- 3L
#    design_method <- "LHS"
#
# An example where the quadratic+Gaussian emulator points up:  
#    seed_inv_prob <- 2562
#    seed_init_design <- 1643
#    N_obs <- 3
#    N_design <- 3L
#    design_method <- "LHS"

library(lhs)
library(kde1d)
library(ggplot2)
library(viridis)
library(parallel)
library(gridExtra)
library(data.table)

base_dir <- getwd()
src_dir <- file.path(base_dir, "src")
output_dir <- file.path(base_dir, "output", "gp_post_approx_paper", "test_1d_visualization")

source(file.path(src_dir, "gp_helper_functions.r"))
source(file.path(src_dir, "gpWrapper.r"))
source(file.path(src_dir, "inv_prob_test_functions.r"))
source(file.path(src_dir, "general_helper_functions.r"))
source(file.path(src_dir, "statistical_helper_functions.r"))
source(file.path(src_dir, "plotting_helper_functions.r"))
source(file.path(src_dir, "llikEmulator.r"))
source(file.path(src_dir, "gp_emulator_functions.r"))
source(file.path(src_dir, "mcmc_helper_functions.r"))
source(file.path(src_dir, "sim_study_functions.r"))
source(file.path(src_dir, "mcmc_calibration_functions.r"))
source(file.path(src_dir, "seq_design.r"))
source(file.path(src_dir, "seq_design_gp.r"))
source(file.path(src_dir, "seq_design_for_post_approx.r"))
source(file.path(src_dir, "gp_mcmc_functions.r"))

# Plot settings applied to all plots. 
design_pt_size <- 4
line_thickness <- 1.5
design_color <- "red"
xlim <- c(-10, 10)
ylim <- c(0.0777, 0.4)

# Random number generator seeds. 
seed_inv_prob <- 2562
seed_init_design <- 16431

# The number of independent observations of the observable (a time average). 
N_obs <- 1L

# Settings for approximate simulation from sample-based approximate posterior. 
# Increasing these values increases the fidelity of the approximation. 
N_monte_carlo_sb <- 100000L

# Settings for noisy MCMC. 
N_mcmc <- 50000
burn_in_start <- N_mcmc/2

# Design point settings. 
N_design <- 3L
design_method <- "LHS"

```


```{r}
#
# Defining the forward model, parameter space, and priors for the inverse problem: 
#    Parameter calibration for VSEM model. Calibrating single parameter implying a 1-dim 
#    input space, and considering an observable in the form of a time average, implying 
#    a 1-dim output space. 
#

set.seed(seed_inv_prob)

# Parameter to calibrate. 
par_cal_name <- "KEXT"

# VSEM default parameter values.
par_names <- get_vsem_par_names()
par_default <- get_vsem_default_pars()
print("Parameter defaults:")
print(data.frame(par_name=par_names, default_value=par_default))

# Define prior on calibration parameter. Setting rownames to "u" so that plot labels 
# will use this generic symbol for the parameter rather than `par_cal_name`. 
par_cal_idx <- which(par_cal_name==par_names)
par_prior_params <- get_vsem_default_priors()[par_cal_idx,,drop=FALSE]
rownames(par_prior_params) <- "u"
print("Prior on calibration parameter:")
print(par_prior_params)
if(par_prior_params$dist=="Uniform") {
  prior_support <- c(par_prior_params$param1, par_prior_params$param2)
} else {
  prior_support<- c(NaN, NaN)
  stop("Currently this notebook is designed assuming uniform prior. Would need to update `estimate_sample_based_density_1d_grid()` is generalizing.")
}

# Number of time points (days) and model driver. 
n_year <- 3
n_time <- 365*n_year
time_points <- 1:n_time
driver <- BayesianTools::VSEMcreatePAR(days=time_points)
plot(time_points, driver, main="Model Driver (PAR)", xlab="Day", ylab="PAR")

# Map from calibration parameter to VSEM outputs.
output_names <- get_vsem_output_names()
lai_idx <- which(output_names=="LAI") 
param_to_output_map <- get_vsem_fwd_model(driver, 1, par_cal_idx, par_default, simplify=FALSE)

# Observation operator (map from model outputs to observable): time average of LAI. 
obs_op <- function(model_outputs) {
  single_run <- (dim(model_outputs)[1]==1L)
  lai_trajectory <- model_outputs[,,lai_idx]
  if(single_run) lai_trajectory <- matrix(lai_trajectory, nrow=1L)
  rowMeans(lai_trajectory)
}

# Forward model: defined here as the calibration parameter-to-observable map. Returns 
# matrix of dimension (N_run,1) to align with the convention of `fwd_model_vectorized`
# in the `llikEmulatorExactGaussDiag` class. 
fwd_model <- function(par_cal) {
  matrix(obs_op(param_to_output_map(par_cal)),ncol=1L)
}
```

```{r}
# Defining the likelihood, ground truth, and observed data for the inverse problem. 
signal_to_noise_ratio <- 20
par_true <- par_default
u_true <- par_true[par_cal_idx]
model_outputs_true <- param_to_output_map(u_true)
y_true <- obs_op(model_outputs_true)
sig_eps <- mean(y_true) / signal_to_noise_ratio
sig2_eps <- sig_eps^2
sig2_true <- sig2_eps # Currently obs variance is fixed, 
                      # so no distinction between exact and estimated variance. 
y <- y_true + sig_eps*rnorm(n=N_obs)

print(paste0("y true: ", y_true))
print(paste0("y obs: ", y))
print(paste0("epsilon std: ", sig_eps))

# Plot ground truth data.  
for(j in 1:dim(model_outputs_true)[3]) {
    output_var <- output_names[j]
    plot(time_points, model_outputs_true[1,,j], xlab="Days", ylab=output_var, main=output_var)
}
```


```{r}
# Instantiate the "exact log-likelihood" object. 
default_conditional <- FALSE
default_normalize <- TRUE
llik_exact <- llikEmulatorExactGaussDiag(llik_lbl="exact", fwd_model=fwd_model, 
                                         y_obs=matrix(y,nrow=N_obs), dim_par=1L, use_fixed_lik_par=TRUE,
                                         sig2=sig2_eps, par_names=rownames(par_prior_params), 
                                         default_conditional=default_conditional, 
                                         default_normalize=default_normalize)
inv_prob <- list(llik_obj=llik_exact, par_prior=par_prior_params, y=y, 
                 par_true=u_true, sig2_true=sig2_true)
```

```{r}
# Generate design and test points.

set.seed(seed_init_design)

# Generate design. 
design_info <- list()
design_info$input <- get_batch_design(design_method, N_design, prior_params=inv_prob$par_prior)
design_info$fwd <- llik_exact$run_fwd_model(design_info$input)[,1]
design_info$llik <- llik_exact$assemble_llik(design_info$input)
design_info$lprior <- calc_lprior_theta(design_info$input, inv_prob$par_prior)

# Grid of test points for plotting and emulator evaluation. The final set of test 
# points will be the union of the test grid with the design points (ensuring the 
# design points are a subset of the test points avoids certain misleading features 
# in the plots that can occur where only some design points are included in the 
# test set). 
N_grid <- 201
u_grid <- get_tensor_product_grid(N_grid, inv_prob$par_prior)
test_info <- list(input=u_grid)
test_info$fwd <- llik_exact$run_fwd_model(test_info$input)[,1] 
test_info$llik <- llik_exact$assemble_llik(test_info$input)
test_info$lprior <- calc_lprior_theta(test_info$input, inv_prob$par_prior)

# Plot true unnormalized posterior density. 
plot(test_info$input, test_info$fwd, type="l", 
     main="True forward model evaluations", xlab="u", ylab="G(u)")
plot(test_info$input, test_info$llik, type="l", 
     main="True log-likelihood", xlab="u", ylab="density")
plot(test_info$input, exp(test_info$llik), type="l", 
     main="True likelihood", xlab="u", ylab="density")
```


```{r}
# 
# Initial design and fit emulators. 
#

# Log-likelihood emulator. 
em_llik_gp <- gpWrapperKerGP(design_info$input, matrix(design_info$llik, ncol=1), 
                             normalize_output=TRUE, scale_input=TRUE)
em_llik_gp$fit("Gaussian_plus_Quadratic", "constant", estimate_nugget=FALSE,
               optimFun="nloptr::nloptr", trace=TRUE, multistart=10)
# em_llik_gp <- gpWrapperHet(design_info$input, matrix(design_info$llik, ncol=1), normalize_output=TRUE, scale_input=TRUE)
# em_llik_gp$fit("Gaussian", "constant", estimate_nugget=FALSE)
em_llik <- llikEmulatorGP("em_llik", em_llik_gp, default_conditional=default_conditional, 
                          default_normalize=default_normalize, lik_par=inv_prob$sig2_true, 
                          use_fixed_lik_par=TRUE)
emulator_pred_llik <- em_llik$predict_emulator(test_info$input, return_cov=TRUE)

# Forward model emulator.
em_fwd_gp <- gpWrapperHet(design_info$input, matrix(design_info$fwd, ncol=1), normalize_output=TRUE, scale_input=TRUE)
em_fwd_gp$fit("Gaussian", "constant", estimate_nugget=FALSE)
em_fwd <- llikEmulatorFwdGaussDiag("em_fwd", em_fwd_gp, matrix(y,nrow=N_obs), sig2=inv_prob$sig2_true, 
                                   default_conditional=default_conditional, 
                                   default_normalize=default_normalize, use_fixed_lik_par=TRUE, 
                                   par_names=rownames(par_prior_params))
emulator_pred_fwd <- em_fwd$predict_emulator(test_info$input, return_cov=TRUE)
```


```{r}
#
# Emulator Distribution plots.  
#

# Probability for confidence intervals to use in plots. 
CI_prob <- pnorm(1) - pnorm(-1) # i.e., plot +/- 1 std dev 
N_std_dev <- 1

# (1): Plot the underlying GP emulator predictive distributions.  
plt_gp_dist_llik <- em_llik$emulator_model$plot_pred_1d(test_info$input, include_interval=TRUE,
                                                        interval_method="pm_std_dev", N_std_dev=N_std_dev,
                                                        pred_list=emulator_pred_llik, ylab="L(u)",
                                                        Y_new=matrix(test_info$llik, ncol=1), line_thickness=line_thickness,
                                                        design_color=design_color, design_pt_size=design_pt_size, 
                                                        xlab="u", plot_title="GP predictions [llik]")[[1]]
plt_gp_dist_fwd <- em_fwd$emulator_model$plot_pred_1d(test_info$input, include_interval=TRUE,
                                                      interval_method="pm_std_dev", N_std_dev=N_std_dev,
                                                      pred_list=emulator_pred_fwd, ylab="G(u)",
                                                      Y_new=matrix(test_info$fwd, ncol=1), line_thickness=line_thickness,
                                                      design_color=design_color, design_pt_size=design_pt_size, 
                                                      xlab="u", plot_title="GP predictions [fwd]")[[1]]

# (2): Plot the log-likelihood emulator predictive distributions. 
plt_llik_dist_llik <- em_llik$plot_pred_1d(test_info$input, emulator_pred_list=emulator_pred_llik,
                                           plot_type="llik", include_interval=TRUE,
                                           interval_method="pm_std_dev", N_std_dev=N_std_dev,
                                           true_llik=test_info$llik, CI_prob=CI_prob, line_thickness=line_thickness,
                                           design_color=design_color, design_pt_size=design_pt_size,
                                           xlab="u", plot_title="log-likelihood predictions [llik]", ylab="L(u)")
plt_llik_dist_fwd <- em_fwd$plot_pred_1d(test_info$input, emulator_pred_list=emulator_pred_fwd,
                                         plot_type="llik", include_interval=TRUE,  
                                         interval_method="pm_std_dev", N_std_dev=N_std_dev,
                                         true_llik=test_info$llik, CI_prob=CI_prob, ylab="L(u)",
                                         design_color=design_color, design_pt_size=design_pt_size,
                                         xlab="u", plot_title="log-likelihood predictions [fwd]")

# (3): Plot the likelihood emulator predictive distributions. 
plt_lik_dist_llik <- em_llik$plot_pred_1d(test_info$input, emulator_pred_list=emulator_pred_llik,
                                          plot_type="lik", include_interval=TRUE, 
                                          interval_method="pm_std_dev", N_std_dev=N_std_dev,
                                          true_llik=test_info$llik, CI_prob=CI_prob, line_thickness=line_thickness,
                                          design_color=design_color, design_pt_size=design_pt_size, ylab="exp L(u)",
                                          xlab="u", plot_title="likelihood predictions [llik]")

# TODO: why doesnt this throw an error when using "CI"?
plt_lik_dist_fwd <- em_fwd$plot_pred_1d(test_info$input, emulator_pred_list=emulator_pred_fwd, 
                                        plot_type="lik", include_interval=TRUE, 
                                        interval_method="pm_std_dev", N_std_dev=N_std_dev,
                                        true_llik=test_info$llik, CI_prob=CI_prob, line_thickness=line_thickness,
                                        design_color=design_color, design_pt_size=design_pt_size, ylab="exp L(u)",
                                        xlab="u", plot_title="likelihood predictions [fwd]")

#
# Plot formatting and saving. 
# 

# Align axes: log-likelihood. 
lims_llik <- get_common_lims(plt_gp_dist_llik, plt_llik_dist_llik, plt_llik_dist_fwd)

# Align axes: likelihood. 
lims_lik <- get_common_lims(plt_lik_dist_llik, plt_lik_dist_fwd)

# GP Emulator plots. 
plt_gp_dist_llik <- ggformat_journal(plt_gp_dist_llik, xlim=lims_llik$xlim, ylim=lims_llik$ylim)
plt_gp_dist_fwd <- ggformat_journal(plt_gp_dist_fwd, xlim=lims_llik$xlim)
plot(plt_gp_dist_llik)
plot(plt_gp_dist_fwd)
ggsave(file.path(output_dir, "gp_dist_llikem.png"), plt_gp_dist_llik)
ggsave(file.path(output_dir, "gp_dist_fwdem.png"), plt_gp_dist_fwd)

# Log-likelihood plots. 
plt_llik_dist_llik <- ggformat_journal(plt_llik_dist_llik, xlim=lims_llik$xlim, ylim=lims_llik$ylim)
plt_llik_dist_fwd <- ggformat_journal(plt_llik_dist_fwd, xlim=lims_llik$xlim, ylim=lims_llik$ylim)
plot(plt_llik_dist_llik)
plot(plt_llik_dist_fwd)
ggsave(file.path(output_dir, "llik_dist_llikem.png"), plt_llik_dist_llik)
ggsave(file.path(output_dir, "llik_dist_fwdem.png"), plt_llik_dist_fwd)

# Likelihood plots. 
plt_lik_dist_llik <- ggformat_journal(plt_lik_dist_llik, xlim=lims_lik$xlim, ylim=lims_lik$ylim)
plt_lik_dist_fwd <- ggformat_journal(plt_lik_dist_fwd, xlim=lims_lik$xlim, ylim=lims_lik$ylim)
plot(plt_lik_dist_llik)
plot(plt_lik_dist_fwd)
ggsave(file.path(output_dir, "lik_dist_llikem.png"), plt_lik_dist_llik)
ggsave(file.path(output_dir, "lik_dist_fwdem.png"), plt_lik_dist_fwd)
```
```{r}
#
# Compute (approximately) normalized exact posterior. 
#

dx <- abs(test_info$input[2] - test_info$input[1])
norm_cst_exact <- int_trap(exp(test_info$llik + test_info$lprior), dx)
test_info$post <- exp(test_info$llik + test_info$lprior) / norm_cst_exact
design_info$post <- exp(design_info$llik + design_info$lprior) / norm_cst_exact

# Store approximated normalizing constants. 
norm_cst_list <- list(exact=norm_cst_exact)
```


```{r}
#
# Comparison of different posterior approximations. 
#

# Convenience functions for normalization. 
approx_norm_cst <- function(lik, dx) {
  int_trap(lik*exp(test_info$lprior), dx)
}

normalize_lik <- function(lik, norm_cst) {
  lik*exp(test_info$lprior) / norm_cst
}

# Log-likelihood emulation. 
post_approx_llik <- em_llik$calc_lik_approx_comparison(test_info$input, approx_types=c("mean", "marginal"), 
                                                       emulator_pred_list=emulator_pred_llik)

norm_cst_llik <- apply(post_approx_llik, 2, function(x) approx_norm_cst(x,dx))
approx_names_llik <- colnames(post_approx_llik)
post_approx_llik <- sapply(1:ncol(post_approx_llik), function(j) normalize_lik(post_approx_llik[,j], norm_cst_llik[j]))
colnames(post_approx_llik) <- approx_names_llik
norm_cst_list$llik <- norm_cst_llik
post_approx_llik_plt <- plot_curves_1d_helper(test_info$input, post_approx_llik, y_new=test_info$post,
                                              X_design=design_info$input, y_design=design_info$post,
                                              plot_title="Posterior Approximations [llik]",
                                              line_thickness=line_thickness, design_color=design_color,
                                              design_pt_size=design_pt_size, xlab="u",  ylab="pi(u)") %>%
                                              ggformat_journal(legend_position="none")
plot(post_approx_llik_plt)

# Forward model emulation. 
post_approx_fwd <- em_fwd$calc_lik_approx_comparison(test_info$input, approx_types=c("mean", "marginal"), 
                                                     emulator_pred_list=emulator_pred_fwd)
norm_cst_fwd <- apply(post_approx_fwd, 2, function(x) approx_norm_cst(x,dx))
approx_names_fwd <- colnames(post_approx_fwd)
post_approx_fwd <- sapply(1:ncol(post_approx_fwd), function(j) normalize_lik(post_approx_fwd[,j], norm_cst_fwd[j]))
colnames(post_approx_fwd) <- approx_names_fwd
norm_cst_list$fwd <- norm_cst_fwd
post_approx_fwd_plt <- plot_curves_1d_helper(test_info$input, post_approx_fwd, y_new=test_info$post,
                                             X_design=design_info$input, y_design=design_info$post,
                                             plot_title="Posterior Approximations [fwd]",
                                             line_thickness=line_thickness, design_color=design_color,
                                             design_pt_size=design_pt_size, xlab="u", 
                                             ylab="pi(u)") %>% ggformat_journal(legend_position="none")
plot(post_approx_fwd_plt)
```

```{r}
# Estimate the sample-based (sb) GP-approximated posterior. We consider this as 
# the "true" Bayesian solution in some sense, to which the other approximations can be compared. 
dens_sb_llik <- estimate_sample_based_density_1d_grid(em_llik, par_prior_params, test_info$input, 
                                                      N_monte_carlo=N_monte_carlo_sb)
dens_sb_fwd <- estimate_sample_based_density_1d_grid(em_fwd, par_prior_params, test_info$input, 
                                                     N_monte_carlo=N_monte_carlo_sb)

post_approx_llik <- cbind(post_approx_llik, `sample`=dens_sb_llik)
post_approx_fwd <- cbind(post_approx_fwd, `sample`=dens_sb_fwd)
```


```{r}
# MCWMH approaches. 

# Initial condition for all MCMC algorithms. 
mcmc_par_init <- sample_prior_theta(inv_prob$par_prior)

#
# Log-likelihood emulator. 
#

# MCWMH-Ind. 
mcmh_nocov_llik_list <- mcmc_gp_noisy(em_llik, inv_prob$par_prior, N_itr=N_mcmc, mode="MCMH", 
                                      use_gp_cov=FALSE, par_init=mcmc_par_init)
samp_dt <- format_mcmc_output(mcmh_nocov_llik_list$samp, test_label="nocov-llik")

# MCWMH-Joint. 
mcmh_cov_llik_list <- mcmc_gp_noisy(em_llik, inv_prob$par_prior, N_itr=N_mcmc, mode="MCMH", 
                                    use_gp_cov=TRUE, par_init=mcmc_par_init)
samp_dt <- append_mcmc_output(samp_dt, mcmh_cov_llik_list$samp, test_label="cov-llik")

#
# Forward model emulator. 
#

# MCWMH-Ind. 
mcmh_nocov_fwd_list <- mcmc_gp_noisy(em_fwd, inv_prob$par_prior, N_itr=N_mcmc, mode="MCMH", 
                                     use_gp_cov=FALSE, par_init=mcmc_par_init)
samp_dt <- append_mcmc_output(samp_dt, mcmh_nocov_fwd_list$samp, test_label="nocov-fwd")

# MCWMH-Joint. 
mcmh_cov_fwd_list <- mcmc_gp_noisy(em_fwd, inv_prob$par_prior, N_itr=N_mcmc, mode="MCMH", 
                                   use_gp_cov=TRUE, par_init=mcmc_par_init)
samp_dt <- append_mcmc_output(samp_dt, mcmh_cov_fwd_list$samp, test_label="cov-fwd")

```


```{r}
# MCMC diagnostics.

trace_plots <- get_trace_plots(samp_dt, burn_in_start=burn_in_start) 
for(plt in trace_plots) plot(plt) 

get_hist_plot_comparisons(samp_dt, test_label_baseline="nocov-llik", 
                          param_types="par", burn_in_start=burn_in_start)
```

```{r}

#
# Produce kernel density approximations of posterior using MCMC samples. 
# 


#
# Log-likelihood emulator. 
#

# MCWMH-Ind. 
kde_fit_mcwmh_ind_llik <- kde1d(select_mcmc_samp(samp_dt, burn_in_start=burn_in_start, 
                                                 test_labels="nocov-llik", param_types="par")$sample, 
                                xmin=prior_support[1], xmax=prior_support[2], deg=2, mult=1)
post_approx_llik <- cbind(post_approx_llik, `mcwmh-ind`=dkde1d(test_info$input, kde_fit_mcwmh_ind_llik))

# MCWMH-Joint. 
kde_fit_mcwmh_joint_llik <- kde1d(select_mcmc_samp(samp_dt, burn_in_start=burn_in_start, 
                                                   test_labels="cov-llik", param_types="par")$sample,
                                  xmin=prior_support[1], xmax=prior_support[2], deg=2, mult=1)
post_approx_llik <- cbind(post_approx_llik, `mcwmh-joint`=dkde1d(test_info$input, kde_fit_mcwmh_joint_llik))

#
# Forward model emulator. 
#

# MCWMH-Ind. 
kde_fit_mcwmh_ind_fwd <- kde1d(select_mcmc_samp(samp_dt, burn_in_start=burn_in_start, 
                                                test_labels="nocov-fwd", param_types="par")$sample,
                               xmin=prior_support[1], xmax=prior_support[2], deg=2, mult=1)
post_approx_fwd <- cbind(post_approx_fwd, `mcwmh-ind`=dkde1d(test_info$input, kde_fit_mcwmh_ind_fwd))

# MCWMH-Joint. 
kde_fit_mcwmh_joint_fwd <- kde1d(select_mcmc_samp(samp_dt, burn_in_start=burn_in_start, 
                                                  test_labels="cov-fwd", param_types="par")$sample,
                                 xmin=prior_support[1], xmax=prior_support[2], deg=2, mult=1)
post_approx_fwd <- cbind(post_approx_fwd, `mcwmh-joint`=dkde1d(test_info$input, kde_fit_mcwmh_joint_fwd))
```


```{r}
#
# Plot: comparison of posterior approximations. 
#

# The kernel density estimates can produce some outlier points at the edges of the domain. We 
# trim off the first and last grid point to avoid this.
N_trim <- 3L
start_idx <- N_trim+1L
stop_idx <- N_grid-N_trim
post_approx_llik_trim <- post_approx_llik[start_idx:stop_idx,]
post_approx_fwd_trim <- post_approx_fwd[start_idx:stop_idx,]
test_input_trim <- test_info$input[start_idx:stop_idx,]
post_trim <- test_info$post[start_idx:stop_idx]

# Log-likelihood emulator. 
post_approx_llik_plt <- plot_curves_1d_helper(test_input_trim, post_approx_llik_trim, y_new=post_trim,
                                              X_design=design_info$input, y_design=design_info$post,
                                              plot_title="Posterior Approximations [llik]",
                                              line_thickness=line_thickness, design_color=design_color,
                                              design_pt_size=design_pt_size, xlab="u",  ylab="pi(u)")
                                              

# Forward model emulator. 
post_approx_fwd_plt <- plot_curves_1d_helper(test_input_trim, post_approx_fwd_trim, y_new=post_trim,
                                             X_design=design_info$input, y_design=design_info$post,
                                             plot_title="Posterior Approximations [llik]",
                                             line_thickness=line_thickness, design_color=design_color,
                                             design_pt_size=design_pt_size, xlab="u",  ylab="pi(u)")

# Align axis limits. 
lims_post_trim <- get_common_lims(post_approx_llik_plt, post_approx_fwd_plt)
post_approx_llik_plt <- post_approx_llik_plt %>% 
                        ggformat_journal(legend_position="bottom", legend.text=element_text(size=20), 
                                         xlim=lims_post_trim$xlim, ylim=lims_post_trim$ylim)
post_approx_fwd_plt <- post_approx_fwd_plt %>% 
                       ggformat_journal(legend_position="bottom", legend.text=element_text(size=20), 
                                        xlim=lims_post_trim$xlim, ylim=lims_post_trim$ylim)


plot(post_approx_llik_plt)
plot(post_approx_fwd_plt)
ggsave(file.path(output_dir, "post_approx_llikem.png"), post_approx_llik_plt)
ggsave(file.path(output_dir, "post_approx_fwdem.png"), post_approx_fwd_plt)

```


```{r}
# Print normalizing constant estimates. 
print("Estimated normalizing constants:")
print(norm_cst_list)
```


# Part 2: Sequential Design 
```{r}
# We consider two classifications of the acquisitions here: 
#    (1) pointwise (pw) vs. integrated (int)
#        The pw acquisition functions only depend on a single input, while the 
#        integrated acquisition functions are a function of the entire input space.
#    (2) Classifying by their "target": gp vs. post.
#        The gp acqusition functions are defined with respect to the underlying GP 
#        emulator, while the post acquisition functions directly target the 
#        likelihood or unnormalized posterior density. 

llik_em_list <- list(llik=em_llik, fwd=em_fwd)

# Compute pointwise acquisitions. 
acq_funcs_pw <- c("llik_neg_var_gp", "llik_neg_entropy_gp", "llik_neg_var_lik")
acq_pw_list <- compare_acq_funcs_by_model(test_info$input, acq_funcs_pw, llik_em_list)
scale_acq <- function(x) scale_inputs(x, target_bounds=c(1,2))
acq_pw_list <- lapply(acq_pw_list, scale_acq)

# Plot pointwise acquisitions. 
acq_pw_plt_llik<- plot_curves_1d_helper(test_info$input, acq_pw_list$llik, plot_title="pointwise acq [llik]",
                                        line_thickness=line_thickness, design_color=design_color,
                                        design_pt_size=design_pt_size, xlab="u", ylab="acq") + 
                                        geom_vline(xintercept=drop(design_info$input), 
                                                    linetype="dashed", color=design_color) 
  
acq_pw_plt_fwd<- plot_curves_1d_helper(test_info$input, acq_pw_list$fwd, plot_title="pointwise acq [fwd]",
                                       line_thickness=line_thickness, design_color=design_color,
                                       design_pt_size=design_pt_size, xlab="u", ylab="acq") + 
                                       geom_vline(xintercept=drop(design_info$input), 
                                                    linetype="dashed", color=design_color)


acq_pw_plt_llik <- acq_pw_plt_llik %>% ggformat_journal(legend_position="bottom",
                                                        legend.text=element_text(size=20))
acq_pw_plt_fwd <- acq_pw_plt_fwd %>% ggformat_journal(legend_position="bottom",
                                                      legend.text=element_text(size=20))

plot(acq_pw_plt_llik)
plot(acq_pw_plt_fwd)

# TODO: add star representing the minimum of each acquisition. 
ggsave(file.path(output_dir, "acq_pw_llik.png"), acq_pw_plt_llik)
ggsave(file.path(output_dir, "acq_pw_fwd.png"), acq_pw_plt_fwd)

```

```{r}
# Integrated criteria: llik 
acq_funcs_int <- c("llik_IVAR_grid_gp", "llik_IENT_grid_gp", "llik_IEVAR_grid")
acq_int_llik <- compare_acq_funcs(test_info$input, acq_funcs_int, em_llik, 
                                  grid_points=test_info$input)
acq_int_llik <- scale_acq(acq_int_llik)
acq_int_plt_llik <- plot_curves_1d_helper(test_info$input, acq_int_llik, 
                                          plot_title="Integrated acq [llik]",
                                          line_thickness=line_thickness, design_color=design_color,
                                          design_pt_size=design_pt_size, xlab="u", ylab="acq") + 
                                          geom_vline(xintercept=drop(design_info$input), 
                                                     linetype="dashed", color=design_color)

# Forward model. 
acq_funcs_int <- c("llik_IVAR_grid_gp", "llik_IENT_grid_gp")
acq_int_fwd <- compare_acq_funcs(test_info$input, acq_funcs_int, em_fwd, 
                                 grid_points=test_info$input)
acq_int_fwd <- scale_acq(acq_int_fwd)
acq_int_plt_fwd <- plot_curves_1d_helper(test_info$input, acq_int_fwd, 
                                         plot_title="Integrated acq [fwd]",
                                         line_thickness=line_thickness, design_color=design_color,
                                         design_pt_size=design_pt_size, xlab="u", ylab="acq") + 
                                         geom_vline(xintercept=drop(design_info$input), 
                                                    linetype="dashed", color=design_color)

acq_int_plt_llik <- acq_int_plt_llik %>% ggformat_journal(legend_position="bottom",
                                                          legend.text=element_text(size=20))
acq_int_plt_fwd <- acq_int_plt_fwd %>% ggformat_journal(legend_position="bottom",
                                                        legend.text=element_text(size=20))


plot(acq_int_plt_llik)
plot(acq_int_plt_fwd)

ggsave(file.path(output_dir, "acq_int_llik.png"), acq_int_plt_llik)
ggsave(file.path(output_dir, "acq_int_fwd.png"), acq_int_plt_fwd)

# TODO:
#    - Should add design points to the set of test points, so that we can see behavior or 
#      acquisitions at the design points. 
#    - Figure out plot formatting/display; add dashed vertical lines for design points, and 
#      stars marking the minima.
#    - When implementing these methods and the acquisition functions that call these methods, 
#      need to think about the case when there are multiple underlying GPs. 
```









