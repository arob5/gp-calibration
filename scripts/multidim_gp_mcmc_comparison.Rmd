---
title: "Higher Dimensional GP-Accelerated MCMC Comparison"
author: "Andrew Roberts"
date: '2023-12-19'
output: html_document
---


```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(lhs)
library(hetGP)
library(mlegp)
library(ggplot2)
library(viridis)
library(parallel)
library(gridExtra)
library(data.table)
library(tmvtnorm)
library(BayesianTools)

source("numerical_experiment_functions.r")
source("mcmc_calibration_functions.r")
source("gp_emulator_functions.r")
source("gp_mcmc_functions.r")
source("sequential_design_optimization.r")
source("sequential_design_sim_study.r")
```


```{r}
# TODOs: 
#    - Write plotting functions suitable for evaluating GP emulators with multivariate input space. Maybe plot y vs. y_hat. 
#    - Update linear Gaussian data generation function: clean up code, improve comments, and allow for non-zero mean Gaussian prior.
#    - Write function to generate linear Gaussian test example in higher dimensions. Include univariate and bivariate 
#      histograms.
#    - Write function analogous to MCMC histogram function that plots bivariate histograms. Will be helpful to get a sense of 
#      how concentrated the true posterior is. 
#    - Step through some MCMC steps to see why it's getting stuck. 
#    - Maybe try putting this model into Stan and seeing how it handles it. 
#    - Try an EKI update to see if this can concentrate in on the posterior in a single time step. 
#    - Try sampling from exact posterior and see how well covariance adaptation does. 
#    - Add MCMC timing information to test function. 
```


```{r}
# Global seed.
set.seed(15)

# Local seeds. 
data_seed <- 23
design_seed <- 40
```


```{r}
# Linear Gaussian Model Setup. 
N_obs <- 100
D <- 6
freqs <- c(0.1, 1, 1.4, 2, 0.5, 1.1)
G <- matrix(nrow=N_obs, ncol=D)
for(d in 1:D) {
  G[,d] <- matrix(sin(2*pi*freqs[d]*seq(1, N_obs)/N_obs), ncol=1)
}

sig2_eps <- 1
Sig0 <- diag(rlnorm(D, meanlog=0, sdlog=2))
mu0 <- rnorm(D, mean=0, sd=4)

# Get synthetic data. 
linear_Gaussian_info <- generate_linear_Gaussian_test_data(data_seed, N_obs, D, Sig0, G, sig2_eps=sig2_eps)
computer_model_data <- linear_Gaussian_info$computer_model_data
theta_prior_params <- linear_Gaussian_info$theta_prior_params

plot(1:N_obs, computer_model_data$data_obs, main="Ground Truth and Observed Data", 
     xlab="t", ylab="y")
lines(1:N_obs, computer_model_data$data_ref, col="red")

```

```{r}

#
# Emulator Setup. 
#

# Emulator settings. 
N_design <- 50
design_method <- "LHS"
emulator_settings <- data.frame(gp_lib = c("hetGP"), 
                                kernel = "Gaussian", 
                                transformation_method = c("truncated"),
                                emulator_target = "SSR",
                                scale_X = TRUE, 
                                normalize_y = TRUE)

# Generate design. 
input_bounds <- rbind(qnorm(.01, theta_prior_params$param1, theta_prior_params$param2), 
                      qnorm(.99, theta_prior_params$param1, theta_prior_params$param2))
rownames(input_bounds) <- c("min", "max")
colnames(input_bounds) <- computer_model_data$pars_cal_names
theta_prior_params_trunc <- truncate_prior_theta(theta_prior_params, input_bounds)

# Initial Design. 
design_settings <- data.frame(N_design=N_design, design_method=design_method)
init_design_info <- get_input_output_design(N_points=design_settings$N_design,
                                            design_method=design_settings$design_method, 
                                            scale_inputs=TRUE,
                                            param_ranges=input_bounds,  
                                            computer_model_data=computer_model_data, 
                                            theta_prior_params=theta_prior_params, design_seed=design_seed)
init_design_info$lpost <- calc_lpost_theta_product_lik(computer_model_data=computer_model_data, 
                                                       theta_vals=init_design_info$inputs, 
                                                       vars_obs=sig2_eps, 
                                                       SSR=init_design_info$outputs,
                                                       na.rm=TRUE, theta_prior_params=theta_prior_params, 
                                                       return_list=FALSE)
  
# Fit emulators on initial design. 
gp_fits <- fit_independent_GPs(X_train=init_design_info$inputs_scaled, Y_train=init_design_info$outputs_normalized, 
                               gp_lib=emulator_settings$gp_lib, gp_kernel=emulator_settings$kernel)$fits
emulator_info_list <- list(gp_fits=gp_fits, input_bounds=init_design_info$input_bounds, 
                           output_stats=init_design_info$output_stats, settings=emulator_settings)

for(fit in gp_fits) plot(fit)
```

```{r}
# Evaluate emulators. 

# TODO: 
#    - Need to ensure validation sets are being sampled within input_bounds. 

N_design_validate <- 5000

# Validation design sampled from true posterior. 
design_post <- t(drop(linear_Gaussian_info$true_posterior$mean) + 
                  t(chol(linear_Gaussian_info$true_posterior$Cov)) %*% 
                    matrix(rnorm(D*N_design_validate), nrow=D, ncol=N_design_validate))
design_post_scaled <- scale_input_data(design_post, input_bounds)
gp_pred_post <- predict_independent_GPs(design_post_scaled, emulator_info_list$gp_fits, emulator_settings$gp_lib, 
                                        include_cov_mat=FALSE, denormalize_predictions=TRUE, 
                                        output_stats=emulator_info_list$output_stats, return_df=TRUE)$df
true_SSR_post <- get_computer_model_SSR(computer_model_data, theta_vals=design_post)                                            

# Validation design sampled from prior. 
design_validate_prior <- get_input_output_design(N_points=N_design_validate,
                                                 design_method="LHS", 
                                                 scale_inputs=TRUE,
                                                 param_ranges=input_bounds,  
                                                 computer_model_data=computer_model_data, 
                                                 theta_prior_params=theta_prior_params)
gp_pred_prior <- predict_independent_GPs(design_validate_prior$inputs_scaled, emulator_info_list$gp_fits,  
                                         emulator_settings$gp_lib, include_cov_mat=FALSE, denormalize_predictions=TRUE, 
                                         output_stats=emulator_info_list$output_stats, return_df=TRUE)$df

plot(design_validate_prior$outputs, gp_pred_prior$mean_output1, xlab="true", ylab="pred", main="prior validation")
points(design_validate_prior$outputs, gp_pred_prior$mean_output1-2*sqrt(gp_pred_prior$var_comb_output1), col="gray")
points(design_validate_prior$outputs, gp_pred_prior$mean_output1+2*sqrt(gp_pred_prior$var_comb_output1), col="gray")

plot(true_SSR_post, gp_pred_post$mean_output1, xlab="true", ylab="pred", main="posterior validation")
points(true_SSR_post, gp_pred_post$mean_output1-2*sqrt(gp_pred_post$var_comb_output1), col="gray")
points(true_SSR_post, gp_pred_post$mean_output1+2*sqrt(gp_pred_post$var_comb_output1), col="gray")

```


```{r}
# Prepare GP-MCMC tests. 

# General settings to apply to all runs. 
N_mcmc <- 50000
learn_sig_eps <- FALSE
sig2_eps_init <- sig2_eps

# Fix pre-MCMC estimates of calibration and likelihood parameters based on design data. All MCMC
# algs will use this initialization. 
best_idx <- which.max(init_design_info$lpost)
theta_init <- init_design_info$inputs[best_idx,]

# TEMP
# theta_init <- computer_model_data$theta_true

# Initialize proposal covariance using design. 
cov_prop_init <- cov(init_design_info$inputs)
# cov_prop_init <- diag(rep(1, D))

# Algorithm-specific settings list. 
run_settings_list <- list()
# run_settings_list[["gibbs_adapt_cov"]] <- list(test_label="gibbs_adapt_cov", 
#                                                alg="ind_gp_gibbs",
#                                                adapt_cov=TRUE, 
#                                                adapt_scale=FALSE)
run_settings_list[["gibbs_traj"]] <- list(test_label="gibbs_traj", 
                                          alg="ind_gp_trajectory",     # "ind_gp_trajectory_trunc_prop",
                                          adapt_cov=TRUE, 
                                          adapt_scale=TRUE,
                                          use_gp_cov=FALSE, 
                                          second_gibbs_step=FALSE, 
                                          cov_prop_init=NULL)
```


```{r}
# Run GP-MCMC algorithms. 
mcmc_test_info <- run_gp_mcmc_tests(run_settings_list, computer_model_data=computer_model_data, 
                                    theta_prior_params=theta_prior_params_trunc,
                                    emulator_info_list=emulator_info_list, theta_init=theta_init,
                                    N_chain=4, N_itr=N_mcmc, burn_ins=NULL, learn_sig_eps=FALSE,
                                    return_cov_prop_scale=TRUE, return_SSR_samp=TRUE, sig2_eps_init=sig2_eps, 
                                    cov_prop_init=cov_prop_init)
mcmc_samp_dt <- mcmc_test_info$mcmc_samp_dt
burn_ins <- mcmc_test_info$burn_ins
```


```{r}
# Append exact posterior samples. 
N_samp_exact <- N_mcmc
samp_exact <- t(drop(linear_Gaussian_info$true_posterior$mean) + 
                t(chol(linear_Gaussian_info$true_posterior$Cov)) %*% matrix(rnorm(D*N_samp_exact), nrow=D, ncol=N_samp_exact))
samp_exact_dt <- as.data.table(samp_exact)
colnames(samp_exact_dt) <- computer_model_data$pars_cal_names
samp_exact_dt[, c("param_type", "itr", "test_label") := list("theta", 1:N_samp_exact, "exact")]
samp_exact_dt <- melt.data.table(samp_exact_dt, id.vars=c("param_type", "itr", "test_label"), 
                                 variable.name="param_name", value.name="sample")

mcmc_samp_dt <- rbindlist(list(mcmc_samp_dt, samp_exact_dt), use.names=TRUE)
```

```{r}
trace_plots <- get_trace_plots(mcmc_samp_dt)
hist_plots <- get_hist_plot_comparisons(mcmc_samp_dt, param_types="theta", test_label_baseline="exact", 
                                        xlab="samples", ylab="density", bins=30)

for(plt in trace_plots) plot(plt)
for(plt in hist_plots) plot(plt)
```



