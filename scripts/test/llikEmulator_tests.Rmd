---
title: "Tests for llikEmulator and Classes which Inherit from llikEmulator"
author: "Andrew Roberts"
date: '2024-02-13'
output: html_document
---

```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(lhs)
library(ggplot2)
library(viridis)
library(parallel)
library(data.table)

base_dir <- getwd()
src_dir <- file.path(base_dir, "src")

source(file.path(src_dir, "gpWrapper.r"))
source(file.path(src_dir, "llikEmulator.r"))
source(file.path(src_dir, "gp_emulator_functions.r"))
source(file.path(src_dir, "sim_study_functions.r"))
source(file.path(src_dir, "mcmc_calibration_functions.r"))
```

```{r}
global_seed <- 22
data_seed <- 9

set.seed(22)
```


```{r}
#
# Linear Gaussian Model to perform tests.  
#

N_obs <- 100
N_missing_output1 <- 4
N_missing_output2 <- 6
u_bound_lower <- 0
u_bound_upper <- 3
u_prior <- data.frame(dist="Uniform", param1=u_bound_lower, param2=u_bound_upper)

# 1D input, 2D output, some missing observations.
G1_mat <- matrix(sin(2*pi*seq(1,N_obs)/N_obs), ncol=1)
G2_mat <- matrix(cos(2*pi*3*seq(1,N_obs)/N_obs), ncol=1)
G <- function(U, ...) abind(y1=G1_mat %*% t(U), y2=G2_mat %*% t(U), along=3)
G_old <- function(u, ...) cbind(y1=u*G1_mat, y2=u*G2_mat)

u_true <- matrix(runif(1, min=u_bound_lower, max=u_bound_upper), nrow=1)
sig2_true <- c(1, 1.5)
G_true <-  G(u_true)[,1,]
Y <- G_true + cbind(rnorm(N_obs, 0, sqrt(sig2_true[1])),
                    rnorm(N_obs, 0, sqrt(sig2_true[2])))
Y[sample.int(N_obs, N_missing_output1),1] <- NA_real_
Y[sample.int(N_obs, N_missing_output2),2] <- NA_real_
colnames(Y) <- c("y1", "y2")
computer_model_data <- list(data_obs=Y, f=G_old, output_vars=c("y1", "y2"))

for(p in 1:ncol(Y)) {
  plot(1:N_obs, Y[,p], main=paste0("Ground Truth and Observed Data: Output ", p),
       xlab="t", ylab=colnames(Y)[p])
  lines(1:N_obs, G_true[,p], col="red")
}

```

```{r}
# 1D input, 1D output example. 
G_1 <- function(U, ...) {cbind(y1=G1_mat %*% t(U))}
sig2_true_1 <- sig2_true[1]
G_true_1 <- G_true[,1,drop=FALSE]
Y_1 <- Y[,"y1",drop=FALSE]
computer_model_data_1 <- list(data_obs=Y_1, f=G_1, output_vars="y1")

plot(1:N_obs, Y_1, main="Ground Truth and Observed Data: 1D Output Test",
     xlab="t", ylab=colnames(Y_1))
lines(1:N_obs, G_true_1, col="red")
```

```{r}
# Generate design points in parameter space. 

# Settings. 
N_design <- 4
N_test <- 51

# Bounds on parameter space.  
input_bounds <- rbind(u_bound_lower, u_bound_upper)
rownames(input_bounds) <- c("min", "max")

# Generate latin hypercube designs. 
design_info <- get_input_output_design(N_points=N_design,
                                       design_method="LHS", 
                                       scale_inputs=FALSE,
                                       normalize_response=FALSE,
                                       param_ranges=input_bounds,  
                                       computer_model_data=computer_model_data, 
                                       theta_prior_params=u_prior)
design_info_1 <- design_info
design_info_1$outputs <- design_info_1$outputs[,1,drop=FALSE]

# Validation data. 
test_info <- get_input_output_design(N_points=N_test,
                                       design_method="grid", 
                                       scale_inputs=FALSE,
                                       normalize_response=FALSE,
                                       param_ranges=input_bounds,  
                                       computer_model_data=computer_model_data, 
                                       theta_prior_params=u_prior)
test_info_1 <- test_info
test_info_1$outputs <- test_info_1$outputs[,1,drop=FALSE]
```

```{r}
# True likelihood for validation inputs. 
llik_true <- matrix(nrow=N_test, ncol=2)
colnames(llik_true) <- c("y1", "y2")
G_test_true <- G(test_info$inputs)

for(i in 1:N_test) {
  for(j in 1:2) {
    llik_true[i,j] <- sum(dnorm(Y[,j], mean=G_test_true[,i,j], sd=sqrt(sig2_true[j]), log=TRUE), na.rm=TRUE)
  }
}

llik_true_1 <- llik_true[,1,drop=FALSE]

```


# Testing llikEmulatorMultGausGP Class using 1D output example. 

```{r}
# First fit GP emulator. 
gp1 <- gpWrapperHet(design_info_1$inputs, design_info_1$outputs, normalize_output=TRUE, scale_input=TRUE)
gp1$fit("Gaussian", "constant")
```


```{r}
# TODO: check issue with Matern kernel. 
# Predict. 
gp1$plot_pred_1d(test_info_1$inputs, Y_new=test_info_1$outputs)
```
```{r}
# Create llikEmulatorMultGausGP object. 
llik_emulator1 <- llikEmulatorMultGausGP(gp1, N_obs=sum(!is.na(Y_1)), sig2=NULL, 
                                         default_conditional=FALSE, default_normalize=FALSE, 
                                         lik_par_fixed=FALSE)
llik_design_1 <- llik_emulator1$assemble_llik(design_info_1$outputs, sig2_true_1, normalize=TRUE)
```

```{r}
# Sample llik emulator: not using cross-input covariance. 
llik_samples_1 <- llik_emulator1$sample(test_info_1$inputs, sig2=sig2_true_1, N_samp=10, use_cov=FALSE, 
                                        include_nugget=TRUE, normalize=TRUE)

matplot(test_info_1$inputs, llik_samples_1, type="l", col="gray", main="llik samples, no-cov")
matlines(test_info_1$inputs, llik_true_1, col="red")
matpoints(design_info_1$inputs, llik_design_1, col="red", pch="o")

# Sample llik_emulator: using cross-input covariance.
llik_samples_1 <- llik_emulator1$sample(test_info_1$inputs, sig2=sig2_true_1, N_samp=10, use_cov=TRUE, 
                                        include_nugget=TRUE, normalize=TRUE)

matplot(test_info_1$inputs, llik_samples_1, type="l", col="gray", main="llik samples, cov")
matlines(test_info_1$inputs, llik_true_1, col="red")
matpoints(design_info_1$inputs, llik_design_1, col="red", pch="o")

```

# Testing llikSumEmulator and llikEmulatorMultGausGP Classes using 2D output example. 

```{r}
# First fit GP emulator. 
gp2 <- gpWrapperHet(design_info$inputs, design_info$outputs[,2,drop=FALSE], normalize_output=TRUE, scale_input=TRUE)
gp2$fit("Gaussian", "constant")
```


```{r}
# TODO: check issue with Matern kernel. 
# Predict. 
gp2$plot_pred_1d(test_info$inputs, Y_new=test_info$outputs[,2,drop=FALSE])
```

```{r}
# Create llikEmulatorMultGausGP object, fixing sig2 this time. 
llik_emulator2 <- llikEmulatorMultGausGP(gp1, N_obs=sum(!is.na(Y[,2])), sig2=sig2_true[2], 
                                         default_conditional=FALSE, default_normalize=TRUE, 
                                         lik_par_fixed=TRUE)
llik_design_2 <- llik_emulator2$assemble_llik(design_info$outputs[,2,drop=FALSE])
```

```{r}
# Sample llik emulator: not using cross-input covariance. 
llik_samples_2 <- llik_emulator2$sample(test_info$inputs, N_samp=10, use_cov=FALSE, include_nugget=TRUE)
                                        

matplot(test_info$inputs, llik_samples_2, type="l", col="gray", main="llik samples, no-cov")
matlines(test_info$inputs, llik_true[,2], col="red")
matpoints(design_info$inputs, llik_design_2, col="red", pch="o")

# Sample llik_emulator: using cross-input covariance.
llik_samples_2 <- llik_emulator2$sample(test_info$inputs, N_samp=10, use_cov=TRUE, 
                                        include_nugget=TRUE)

matplot(test_info$inputs, llik_samples_2, type="l", col="gray", main="llik samples, cov")
matlines(test_info$inputs, llik_true[,2], col="red")
matpoints(design_info$inputs, llik_design_2, col="red", pch="o")

```















```{r}
# Sample 
gpHet1_samp <- gpHet1$sample(X1_new, use_cov=TRUE, N_samp=5, pred_list=gpHet1_pred)
for(i in 1:gpHet1$Y_dim) {
  matplot(X1_new, gpHet1_samp[,,i],type="l")
  lines(X1_new, Y1_new_noiseless[,i], col="red")
}
```

# 2d validation. 

## hetGP
```{r}
# Fit
gpHet2 <- gpWrapperHet(X2, Y2, normalize_output=TRUE, scale_input=TRUE)
gpHet2$fit("Matern3_2", "constant", estimate_nugget=FALSE)
```

```{r}
# TODO: Add plot_pred_2d for 2d heatmap plots so I can validate this plot. 
# TODO: Add prediction intervals. 
# Predict and plot. 
# gpHet2_pred <- gpHet2$predict(X2_new)
gpHet2$plot_pred(X2_new, Y2_new)
```







