#
# inv_prob_test_functions.r
# Convenience functions related to the definition of the components defining
# a Bayesian inverse problem (forward model, prior distribution, etc.).
#
# Andrew Roberts
#

library(assertthat)
library(BayesianTools) # For the VSEM toy ecosystem model.

# -----------------------------------------------------------------------------
# Very Simple Ecosystem Model (VSEM):
#
# The VSEM model in the BayesianTools R package provides a convenient toy 
# example of an ecosystem model that is very fast/simple, but mimics the 
# general strcture of more complicated models. The functions here are 
# wrappers around the BayesianTools code that provide the functionality 
# to quickly define a forward model/inverse problem based on the VSEM 
# model. 
# -----------------------------------------------------------------------------

get_vsem_par_names <- function() {
  # Returns a character vector of the VSEM parameter names as specified by 
  # the BayesianTools `VSEMgetDefaults()` function. The order of the 
  # names in the returned vector is meant to establish the "official" 
  # parameter order in tests using the VSEM model. 
  
  rownames(BayesianTools::VSEMgetDefaults())
}

get_vsem_output_names <- function() {
  # Returns a character vector of the output variables returned by the 
  # VSEM forward model `fwd_vsem()` or forward models returned by 
  # `get_vsem_fwd_model()`. Note that this includes the variables 
  # returned by the BayesianTools `VSEM()` function in addition to 
  # variables that are added by the wrapper functions defined here; 
  # e.g., Leaf Area Index (LAI). Analogous to `get_vsem_par_names()`, 
  # the character vector returned here is meant to establish an 
  # official output variable order. 
  
  c("NEE", "Cv", "Cs", "CR", "LAI")
  
}

get_vsem_default_pars <- function() {
  # A convenience function returning default parameters for the VSEM parameters,
  # following the parameter order convention specified by `get_vsem_par_names()`.
  # Currently, this uses the values given in the "best" column of the data.frame 
  # returned by BayesianTools' `VSEMgetDefaults()` but this could conceivably 
  # change if defaults differing from those specified by BayesianTools are 
  # desired. 
  par_name_order <- get_vsem_par_names()
  BayesianTools::VSEMgetDefaults()[par_name_order, "best"]
}

get_vsem_default_priors <- function() {
  # A convenience function to return default priors for the VSEM model
  # parameters, including the initial conditions. Note that this does not
  # align with the bounds provided in the R BayesianTools function
  # `VSEMgetDefaults()`.
  
  # Default priors.
  par_priors <- list()
  par_priors$par_name <- c("KEXT","LAR","LUE","GAMMA","tauV","tauS","tauR",
                           "Av","Cv","Cs","Cr")
  par_priors$dist <- rep("Uniform", length(par_priors$par_name))
  par_priors$param1 <- c(2e-01,2e-01,5e-04,2e-01,5e+02,4e+03,5e+02,2e-01,0.0,0.0,0.0)
  par_priors$param2 <- c(1.0,3.0,4e-03,6e-01,3e+03,5e+04,3e+03,1.0,10.0,30.0,10.0)
  par_priors$bound_lower <- par_priors$param1
  par_priors$bound_upper <- par_priors$param2
  par_priors <- as.data.frame(par_priors)

  # Ensure parameter names/order is correct. 
  vsem_par_name_order <- get_vsem_par_names()
  assert_that(all(vsem_par_name_order==par_priors$par_name))
  
  # Set rownames attribute to the parameter names for compatiblity with prior
  # distribution functions. 
  rownames(par_priors) <- par_priors$par_name

  return(par_priors)
}


solve_vsem <- function(driver, par) {
  # A wrapper around BayesianTools' function `VSEM()` which implements a 
  # simple Euler discretization of the VSEM ordinary differential 
  # equation. The main purpose of this wrapper is to add on additional 
  # output variables to the variables returned by `VSEM()`. 
  #
  # Args:
  #    driver: numeric(), vector containing the driving/forcing data for 
  #            the VSEM model. This is typically generated by calling 
  #            `BayesianTools::VSEMcreatePAR()`. The length of this 
  #            vector determines the number of time points in the 
  #            discretization and hence the number of rows in the matrix
  #            returned by `solve_vsem()`. 
  #   par: numeric(), vector containing the parameter values to 
  #        use. Must contain values for all VSEM parameters in 
  #        the correct order, as required by BayesianTools. 
  #
  # Returns: 
  #    matrix of shape (N_time, N_output) where `N_time` is the number 
  #    of time points at which the VSEM solution was approximated 
  #    and `N_output` is the number of output variables. The output 
  #    variables are sorted according to `get_vsem_output_names()`. 
  
  output_var_order <- get_vsem_output_names()
  par_names_order <- get_vsem_par_names()
  
  # VSEM output. 
  vsem_output <- VSEM(pars=par, PAR=driver)
  
  # Augment output by computing Leaf Area Index (LAI) trajectory. 
  lai_idx <- which(par_names_order=="LAR")
  lai_trajectory <- par[lai_idx] * vsem_output[,"Cv"]
  vsem_output <- cbind(vsem_output, LAI=lai_trajectory)
  
  assert_that(all(output_var_order==colnames(vsem_output)))
  return(vsem_output)
  
}


fwd_vsem <- function(par_cal, driver, par_cal_idx=NULL, par_default=NULL, simplify=TRUE) {
  # A convenience function defining a "forward map" for the VSEM model. This is
  # map from the calibration parameter (which includes initial conditions)
  # to the model outputs, which are the simulated trajectories of the
  # output variables. Note that the calibration parameters often represent a
  # subset of the set of 11 VSEM parameters. If this is the case, then
  # `par_cal_idx` must be specified, which is an array giving the indices
  # of the calibration parameters within the 11-dimensional full parameter
  # vector. In this case, the values of the calibration parameters will be set
  # to `par_cal`, while the values of the remaining "fixed" parameters are
  # set to those specified in `par_default`. If `par_default` is NULL, then
  # it is set to `get_vsem_default_pars()`. Note that `par_default` must
  # be a vector of length 11, containing ALL of the parameters. `par_cal` will
  # replace the values of the calibration parameters within this vector.
  # Finally, note that `fwd_vsem()` is vectorized so that multiple runs can
  # be conducted at different values of the calibration parameters. In this
  # case `par_cal` should be a matrix of dimension (N_runs, N_cal), where
  # N_cal is the number of calibration parameters. For a single run, a
  # matrix of shape (1,N_cal) or a `N_cal` length vector is allowed. 
  # For now, the same default values for the fixed parameters are used 
  # across all runs, but this could change in the future. Note that 
  # `get_vsem_par_names()` defines the official ordering for the VSEM 
  #
  # Returns:
  # An array of shape (N_runs, N_time_step, N_outputs). If there is 
  # is only 1 run and `simplify` is TRUE, then the output dimension 
  # is simplified to (N_time_step, N_outputs). 

  # Ensure `par_cal` dimension is consistent with single run or multiple runs.
  if(is.vector(par_cal)) {
    par_cal <- matrix(par_cal, nrow=1)
  } else if(!is.matrix(par_cal)) {
    stop("`par_cal` must be a numeric vector or a matrix.")
  }
  
  # If the set of calibration parameters is a subset of all VSEM parameters,
  # ensure that `par_cal_idx` is provided, and define defaults for the parameters
  # being fixed.
  par_names <- get_vsem_par_names()
  n_par_vsem = length(par_names)
  n_par_cal <- ncol(par_cal)
  par_cal_is_subset <- TRUE
  if(n_par_cal < n_par_vsem) {
    assert_that(!is.null(par_cal_idx), 
                msg="`par_cal_idx` is NULL but `n_par_cal < n_par_vsem`")
    assert_that(length(par_cal_idx)==n_par_cal)
    if(is.null(par_default)) par_default <- get_vsem_default_pars()
    else assert_that(length(par_default)==n_par_vsem)
  } else if(n_par_cal > n_par_vsem) {
    stop("Number of calibration parameters exceeds number of VSEM parameters.")
  } else {
    par_cal_is_subset <- FALSE 
  }
  
  # Execute forward model evaluations. For now this is done in a loop, but
  # parallelization may be added in the future.
  vsem_output_names <- get_vsem_output_names()
  n_time_step <- length(driver)
  n_run <- nrow(par_cal)
  n_output = length(vsem_output_names)
  model_output <- array(NA_real_, dim=c(n_run,n_time_step,n_output))
  
  for(i in 1:n_run) {
    if(par_cal_is_subset) {
      par_run <- par_default
      par_run[par_cal_idx] <- par_cal[i,]
    } else {
      par_run <- par_cal[i,]
    }
    model_output[i,,] <- solve_vsem(driver, par_run)
  }
  
  # Optionally simplify dimension for the single-run case.
  if((n_run==1) && simplify) model_output <- model_output[1,,]

  return(model_output)
  
}


get_vsem_fwd_model <- function(driver, n_par_cal, par_cal_idx=NULL, 
                               par_default=NULL, simplify=TRUE) {
  # A convenience function that returns a function representing the VSEM
  # forward model `fwd_vsem()` but only as an argument of `par_cal`, with the
  # remaining arguments fixed. This is convenient for parameter estimation
  # analyses where the remaining arguments (e.g., the model driver and the 
  # fixed parameters) will be fixed throughout the analysis. Also includes 
  # a check to ensure the parameter dimension is correct.
    
  fwd <- function(par_cal) {
    if(is.vector(par_cal)) assert_that(length(par_cal)==n_par_cal)
    else assert_that(ncol(par_cal)==n_par_cal)
    
    return(fwd_vsem(par_cal, driver, par_cal_idx, par_default, simplify))
  }
  
  return(fwd)
}


get_vsem_inv_prob_new <- function(par_cal_names, obs_op, sig2_true, sig2_model,
                                  vsem_prior, par_true, par_model, n_day) {
  # An updated version of `get_vsem_inv_prob`. Keeping the old version to 
  # avoid breaking code that utilizes it. The "_true" values are used to 
  # generate synthetic data. The "_model" values are used in the model defining
  # the inverse problem. If the two sets of values are the same then there 
  # is no model misspecification. In this function, "par" or "parameters" 
  # refers to ALL VSEM parameters. The subset that will be learned are 
  # referred to as "calibration parameters" (par_cal). The non-calibration
  # parameters (i.e., the fixed parameters) will be set to the values found
  # in `par_model`.
  #
  # Arguments:
  #    par_cal_names: Subset of `get_vsem_par_names()` that will be calibrated.
  #                   The remainder will be fixed.
  #    obs_op: The observation operator. For a forward model `fwd` returned
  #            by `get_vsem_fwd_model()`, the `obs_op` function must be 
  #            able to be called like `obs_op(fwd(par))`, where `par` can be
  #            a matrix (ensemble of parameter values).
  #    sig2_true: ground truth noise variance.
  #    sig2_model: model noise variance.
  #    vsem_prior: data.frame prior object for all VSEM parameters. A default
  #                prior can be generated by `get_vsem_default_priors()`.
  #    par_true: ground truth VSEM parameters.
  #    par_model: VSEM parameters used to set values of fixed parameters.
  #    n_day: number of days that SIPNET will be simulated for.
  
  # Generate driver/forcing data.
  time_points <- seq(1L,n_day)
  driver <- BayesianTools::VSEMcreatePAR(days=time_points)
  output_names <- get_vsem_output_names()
  
  # Calibration parameters.
  par_names <- get_vsem_par_names()
  assert_that(all(par_cal_names %in% par_names))
  assert_that(all(!duplicated(par_cal_names)))
  par_cal_idx <- match(par_cal_names, par_names)
  par_cal_prior <- vsem_prior[par_cal_names,,drop=FALSE]
  par_cal_true <- par_true[par_cal_idx]
  dim_par <- length(par_cal_names)
  
  # Forward map from calibration parameters to VSEM outputs. If the default 
  # parameters differ from the true parameters, then there will be two maps 
  # here: one "true" map used to generate the synthetic data and one map that 
  # will be used to define the inverse problem.
  par_to_output_map <- get_vsem_fwd_model(driver, dim_par, par_cal_idx, 
                                          par_model, simplify=FALSE)
  par_to_output_map_true <- get_vsem_fwd_model(driver, dim_par, par_cal_idx, 
                                               par_true, simplify=FALSE)
  
  # Define the parameter-to-observation map by taking the composition of the 
  # VSEM forward model with the observation operator. 
  par_to_obs_op <- function(par_cal) {obs_op(par_to_output_map(par_cal))}
  par_to_obs_op_true <- function(par_cal) {obs_op(par_to_output_map_true(par_cal))}
  
  # Generate ground truth states (i.e., model outputs) and observable. 
  model_output_true <- par_to_output_map_true(par_cal_true)
  y_true <- obs_op(model_output_true)
  
  # Generate synthetic observed data, which is a perturbed version of the 
  # output signal.
  dim_obs <- length(drop(y_true))
  y <- y_true + sqrt(sig2_true)*rnorm(n=dim_obs)
  
  # Generate the states and observable implied by running the approximate 
  # model (i.e., the model with potentially misspecified values of the fixed
  # parameters) at the true values of the calibration parameters.
  output_true_model <- par_to_output_map(par_cal_true)
  y_model <- obs_op(output_true_model)
  
  # Assemble list to return.
  inv_prob_list <- list(time_points=time_points, driver=driver, 
                        vsem_par_names=par_names, par_names=par_cal_names,
                        par_cal_idx=par_cal_idx, output_names=output_names,
                        vsem_par_default=par_model, vsem_par_true=par_true,
                        par_true=par_true[par_cal_names],
                        vsem_par_prior=vsem_prior, par_prior=par_cal_prior,
                        n_day=n_day, dim_par=dim_par, dim_obs=dim_obs,
                        par_to_output_map=par_to_output_map, 
                        par_to_output_map_true=par_to_output_map_true, 
                        obs_op=obs_op, par_to_obs_op=par_to_obs_op,
                        par_to_obs_op_true=par_to_obs_op_true,
                        sig2_true=sig2_true, sig2_model=sig2_model, 
                        model_output_true=model_output_true, y_true=y_true, 
                        output_true_model=output_true_model, y_model=y_model,
                        y=y)
  
  # Add data.frame providing a convenient summary of all parameters and their 
  # priors.
  par_info <- inv_prob_list$vsem_par_prior
  par_info$calibrate <- par_info$par_name %in% inv_prob_list$par_names
  par_info$default <- inv_prob_list$vsem_par_default
  par_info$true_value <- inv_prob_list$vsem_par_true
  inv_prob_list$par_info <- par_info
  
  return(inv_prob_list)
}



get_vsem_inv_prob <- function(par_cal_names, obs_op, sig2_true=NULL, n_day=365*3, 
                              par_true=NULL, par_prior=NULL, sample_truth_from_prior=TRUE,
                              sig2_method="estimate", sig2_fixed=NULL, 
                              signal_to_noise_ratio=20, driver_seed=NULL, par_true_seed=NULL, 
                              obs_seed=NULL) {
  # Currently this function defines a Gaussian likelihood consisting of additive 
  # Gaussian errors with variance `sig2_true`. This can be generalized in the future
  # to consider non-diagonal covariance structure or non-Gaussian likelihoods.
  # If `sig2_true` then this value is determined by`signal_to_noise_ratio`. 
  # The value `sig2_true` is used in generating the synthetic data. If 
  # `sig2_method = "known"` then this true value is also used to define the 
  # inverse problem (i.e., the likelihood is correctly specified). If 
  # `sig2_method = "estimate"` (default) then the variance defining the inverse 
  # problem is fixed at its sample variance estimate.
  #
  # The convention in the returned list is that "par" refers to the calibration 
  # parameters, while "vsem_par" refers to the entire set of VSEM parameters 
  # (including those that are being fixed).
  
  # Generate driver/forcing data.
  if(!is.null(driver_seed)) set.seed(driver_seed)
  time_points <- seq(1,n_day)
  driver <- BayesianTools::VSEMcreatePAR(days=time_points)
  output_names <- get_vsem_output_names()

  # VSEM default parameter values. If `sample_truth_from_prior` is FALSE and, 
  # `par_true` is NULL these will also correspond to the ground truth parameter 
  # values used to generate the the synthetic data.
  par_names <- get_vsem_par_names()
  par_default <- get_vsem_default_pars()
  
  # Prior distributions on parameter values. If `sample_truth_from_prior` is TRUE 
  # and `par_true` is NULL then the ground truth parameter values will be sampled 
  # from this prior.
  if(is.null(par_prior)) par_prior <- get_vsem_default_priors()
  assert_that(setequal(par_names, rownames(par_prior)))
  
  # Define the "ground truth" parameter values that will be used to generate the 
  # synthetic data. The argument `par_true` takes priority. If this is not 
  # provided then the ground truth is either sampled from the prior 
  # (when `sample_truth_from_prior` is TRUE), or otherwise set to `par_default`.
  par_fixed_exact <- FALSE 
  if(is.null(par_true)) {
    if(sample_truth_from_prior) {
      if(!is.null(par_true_seed)) set.seed(par_true_seed)
      par_true <- sample_prior(par_prior)
    } else {
      par_true <- par_default
      par_fixed_exact <- FALSE
    }
  } else {
    # Ensure all parameters are present and sort to align with required order.
    assert_that(setequal(names(par_true), par_names))
    par_true <- par_true[par_names]
  }
  
  # Determine the subset of parameters that will be calibrated.
  assert_that(all(par_cal_names %in% par_names))
  assert_that(all(!duplicated(par_cal_names)))
  par_cal_idx <- match(par_cal_names, par_names)
  par_cal_prior <- par_prior[par_cal_names,,drop=FALSE]
  par_cal_true <- par_true[par_cal_idx]
  dim_par <- length(par_cal_names)
  
  # Forward map from calibration parameters to VSEM outputs. If the default 
  # parameters differ from the true parameters, then there will be two maps 
  # here: one "true" map used to generate the synthetic data and one map that 
  # will be used to define the inverse problem.
  par_to_output_map <- get_vsem_fwd_model(driver, dim_par, par_cal_idx, 
                                          par_default, simplify=FALSE)
  par_to_output_map_true <- get_vsem_fwd_model(driver, dim_par, par_cal_idx, 
                                               par_true, simplify=FALSE)

  # Define the parameter-to-observation map by taking the composition of the 
  # VSEM forward model with the observation operator. 
  par_to_obs_op <- function(par_cal) {obs_op(par_to_output_map(par_cal))}
  par_to_obs_op_true <- function(par_cal) {obs_op(par_to_output_map_true(par_cal))}
  
  # Generate ground truth output signal. 
  if(!is.null(obs_seed)) set.seed(obs_seed)
  model_output_true <- par_to_output_map_true(par_cal_true)
  y_true <- obs_op(model_output_true)
  
  # Set true observation variance parameter.
  if(is.null(sig2_true)) {
    sig2_true <- (mean(y_true) / signal_to_noise_ratio)^2
  }
  
  # Generate synthetic observed data, which is a perturbed version of the 
  # output signal.
  dim_obs <- length(drop(y_true))
  y <- y_true + sqrt(sig2_true)*rnorm(n=dim_obs)
  
  # Set variance parameter that will be used in defining the inverse problem.
  if(sig2_method=="estimate") {
    sig2_model <- var(drop(y))
  } else if(sig2_method=="known") {
    sig2_model <- sig2_true
  } else if(sig2_method=="fixed") {
    assert_that(!is.null(sig2_fixed))
    sig2_model <- sig2_fixed
  } else {
    stop("Invalid `sig2_method` argument: ", sig2_method)
  }
  
  # Assemble list to return.
  inv_prob_list <- list(time_points=time_points, driver=driver, 
                        vsem_par_names=par_names, par_names=par_cal_names,
                        par_cal_idx=par_cal_idx, output_names=output_names,
                        vsem_par_default=par_default, vsem_par_true=par_true,
                        par_true=par_true[par_cal_names],
                        vsem_par_prior=par_prior, par_prior=par_cal_prior,
                        par_fixed_exact=par_fixed_exact,
                        n_day=n_day, dim_par=dim_par, dim_obs=dim_obs,
                        par_to_output_map=par_to_output_map, 
                        par_to_output_map_true=par_to_output_map_true, 
                        obs_op=obs_op, par_to_obs_op=par_to_obs_op,
                        par_to_obs_op_true=par_to_obs_op_true,
                        sig2_true=sig2_true, sig2_model=sig2_model, 
                        sig2_method=sig2_method, model_output_true=model_output_true,
                        y_true=y_true, y=y, driver_seed=NULL, par_true_seed=NULL, 
                        obs_seed=NULL)
  
  # Add data.frame providing a convenient summary of all parameters and their 
  # priors.
  par_info <- inv_prob_list$vsem_par_prior
  par_info$calibrate <- par_info$par_name %in% inv_prob_list$par_names
  par_info$default <- inv_prob_list$vsem_par_default
  par_info$true_value <- inv_prob_list$vsem_par_true
  inv_prob_list$par_info <- par_info
  
  return(inv_prob_list)
  
}


get_vsem_test_1 <- function(default_conditional=FALSE, default_normalize=TRUE) {
  # A convenience function that sets up an inverse problem using VSEM in a 
  # reproducible fashion. 
  
  # Random seeds. 
  driver_seed <- 623434
  par_true_seed <- 7854332
  obs_seed <- 5632
  
  # Observation operator (map from model outputs to observable): daily LAI observations. 
  output_names <- get_vsem_output_names()
  observed_output <- "LAI"
  lai_idx <- match(observed_output, output_names)
  obs_op <- function(model_outputs) {
    single_run <- (dim(model_outputs)[1]==1L)
    lai_trajectory <- model_outputs[,,lai_idx]
    if(single_run) lai_trajectory <- matrix(lai_trajectory, nrow=1L)
    lai_trajectory
  }
  
  # Ground truth parameters (differ from VSEM defaults). 
  par_true <- c(KEXT=0.42, LAR=1.6, LUE=0.006, GAMMA=0.2, tauV=1000, tauS=30000,
                tauR=1000, Av=0.3, Cv=3.4, Cs=14.0, Cr=2.6)
  
  # Parameters to calibrate. 
  par_cal_names <- c("KEXT", "GAMMA", "LUE", "tauV", "Cv")
  
  # Priors: using defaults with some modifications.
  par_prior <- get_vsem_default_priors()
  # par_prior["Av","param2"] <- 0.7
  
  # Set up inverse problem. 
  inv_prob <- get_vsem_inv_prob(par_cal_names, obs_op, par_true=par_true, 
                                par_prior=par_prior, sig2_method="fixed", 
                                sig2_fixed=(0.7)^2, signal_to_noise_ratio=20, 
                                driver_seed=driver_seed, 
                                par_true_seed=par_true_seed, obs_seed=obs_seed)
  
  # Define exact log-likelihood object. 
  llik_exact <- llikEmulatorExactGaussDiag(llik_lbl="exact", 
                                           fwd_model=inv_prob$par_to_obs_op, 
                                           fwd_model_vectorized=inv_prob$par_to_obs_op,
                                           y_obs=inv_prob$y, 
                                           dim_par=as.integer(inv_prob$dim_par),
                                           sig2=inv_prob$sig2_model,
                                           par_names=inv_prob$par_names, 
                                           default_conditional=default_conditional, 
                                           default_normalize=default_normalize)
  inv_prob$llik_obj <- llik_exact
  
  return(inv_prob)
}


get_vsem_test_paper <- function(default_conditional=FALSE, default_normalize=TRUE,
                                period=30, n_day=24*30) {
  # A variation of `get_vsem_test_1_time_avg` that changes the default prior 
  # distribution. In this case, prior support is unbounded. The example used 
  # as a tutorial in the review paper.

  # Observation operator (map from model outputs to observable): time averages
  # of LAI observations.
  output_names <- get_vsem_output_names()
  observed_output <- "LAI"
  lai_idx <- match(observed_output, output_names)
  
  get_period_mean <- function(x, time_period=period) {
    start_pts <- seq(1, length(x), by=time_period)
    sapply(start_pts, function(i) mean(x[i:min(i + time_period - 1, length(x))]))
  }
  
  obs_op <- function(model_outputs) {
    single_run <- (dim(model_outputs)[1] == 1L)
    lai_trajectory <- model_outputs[,,lai_idx]
    
    if(single_run) {
      lai_avg <- matrix(get_period_mean(lai_trajectory), nrow=1L)
    } else {
      lai_avg <- t(apply(lai_trajectory, 1, get_period_mean))
    }
    return(lai_avg)
  }
  
  # Priors: modifying defaults. Note that Gamma uses shape-rate parameterization.
  par_prior <- as.data.table(get_vsem_default_priors())
  par_prior[par_name=="KEXT", `:=`(dist="Beta", param1=2, param2=2, bound_lower=0, bound_upper=1)]
  par_prior[par_name=="LAR", `:=`(dist="Gamma", param1=4, param2=2, bound_lower=0, bound_upper=Inf)]
  par_prior[par_name=="LUE", `:=`(dist="Gamma", param1=2, param2=400, bound_lower=0, bound_upper=Inf)]
  par_prior[par_name=="GAMMA", `:=`(dist="Beta", param1=1.5, param2=3.0, bound_lower=0, bound_upper=1)]
  par_prior[par_name=="tauV", `:=`(dist="Gamma", param1=3.5, param2=0.003, bound_lower=0, bound_upper=Inf)]
  par_prior[par_name=="tauS", `:=`(dist="Gamma", param1=3.0, param2=0.00015, bound_lower=0, bound_upper=Inf)]
  par_prior[par_name=="tauR", `:=`(dist="Gamma", param1=3.0, param2=0.00015, bound_lower=0, bound_upper=Inf)]
  par_prior[par_name=="Av", `:=`(dist="Beta", param1=2, param2=2, bound_lower=0, bound_upper=1)]
  par_prior[par_name=="Cv", `:=`(dist="Gamma", param1=10, param2=2.0, bound_lower=0, bound_upper=Inf)]
  par_prior[par_name=="Cs", `:=`(dist="Gamma", param1=17, param2=1, bound_lower=0, bound_upper=Inf)]
  par_prior[par_name=="Cr", `:=`(dist="Gamma", param1=10, param2=2, bound_lower=0, bound_upper=Inf)]
  par_prior <- as.data.frame(par_prior)
  rownames(par_prior) <- par_prior$par_name
  
  # Ground truth parameters. 
  par_true <- setNames(get_vsem_default_pars(), get_vsem_par_names())
  
  # Parameters used to set values of fixed parameters in inverse problem model.
  par_model <- drop(sample_prior(par_prior))

  # Parameters to calibrate.
  par_cal_names <- c("KEXT", "GAMMA", "tauV", "Cv")
  
  # Ground truth vs model noise variance.
  sig2_true <- (0.5)^2
  sig2_model <- (0.7)^2
  
  # Set up inverse problem. 
  inv_prob <- get_vsem_inv_prob_new(par_cal_names=par_cal_names, obs_op=obs_op, 
                                    sig2_true=sig2_true, sig2_model=sig2_model,
                                    vsem_prior=par_prior, par_true=par_true, 
                                    par_model=par_model, n_day=n_day)
  inv_prob$output_idx <- lai_idx
  
  # Define exact log-likelihood object. 
  llik_exact <- llikEmulatorExactGaussDiag(llik_lbl="exact", fwd_model=inv_prob$par_to_obs_op, 
                                           fwd_model_vectorized=inv_prob$par_to_obs_op,
                                           y_obs=inv_prob$y, dim_par=as.integer(inv_prob$dim_par),
                                           sig2=inv_prob$sig2_model,
                                           par_names=inv_prob$par_names, 
                                           default_conditional=default_conditional, 
                                           default_normalize=default_normalize)
  inv_prob$llik_obj <- llik_exact
  
  return(inv_prob)
}


get_vsem_test_1_time_avg <- function(default_conditional=FALSE, default_normalize=TRUE, period=30) {
  # A slight variation on the inverse problem defined by `get_vsem_test_1()`
  # whereby the observation operator has been defined to construct averages 
  # of length `period` days. The default `period=30` constructs monthly averages.
  
  # Random seeds. 
  driver_seed <- 623434
  par_true_seed <- 7854332
  obs_seed <- 5632
  
  # Observation operator (map from model outputs to observable): time averages
  # of LAI observations.
  output_names <- get_vsem_output_names()
  observed_output <- "LAI"
  lai_idx <- match(observed_output, output_names)

  get_period_mean <- function(x, time_period=period) {
    start_pts <- seq(1, length(x), by = time_period)
    sapply(start_pts, function(i) mean(x[i:min(i + time_period - 1, length(x))]))
  }
    
  obs_op <- function(model_outputs) {
    single_run <- (dim(model_outputs)[1] == 1L)
    lai_trajectory <- model_outputs[,,lai_idx]
      
    if (single_run) {
      lai_avg <- matrix(get_period_mean(lai_trajectory), nrow=1L)
    } else {
      lai_avg <- t(apply(lai_trajectory, 1, get_period_mean))
    }
    return(lai_avg)
  }

  # Ground truth parameters (differ from VSEM defaults). 
  par_true <- c(KEXT=0.42, LAR=1.6, LUE=0.006, GAMMA=0.2, tauV=1000, tauS=30000,
                tauR=1000, Av=0.3, Cv=3.4, Cs=14.0, Cr=2.6)
  
  # Parameters to calibrate. 
  par_cal_names <- c("KEXT", "GAMMA", "LUE", "tauV", "Cv")
  
  # Priors: using defaults with some modifications.
  par_prior <- get_vsem_default_priors()
  
  # Set up inverse problem. 
  inv_prob <- get_vsem_inv_prob(par_cal_names, obs_op, par_true=par_true, par_prior=par_prior,
                                sig2_method="fixed", sig2_fixed=(0.7)^2, signal_to_noise_ratio=20, 
                                driver_seed=driver_seed, par_true_seed=par_true_seed, 
                                obs_seed=obs_seed)
  
  # Define exact log-likelihood object. 
  llik_exact <- llikEmulatorExactGaussDiag(llik_lbl="exact", fwd_model=inv_prob$par_to_obs_op, 
                                           fwd_model_vectorized=inv_prob$par_to_obs_op,
                                           y_obs=inv_prob$y, dim_par=as.integer(inv_prob$dim_par),
                                           sig2=inv_prob$sig2_model,
                                           par_names=inv_prob$par_names, 
                                           default_conditional=default_conditional, 
                                           default_normalize=default_normalize)
  inv_prob$llik_obj <- llik_exact
  
  return(inv_prob)
}


get_vsem_test_1d_vis <- function(default_conditional=FALSE, default_normalize=TRUE) {
  # A toy example with a single calibration parameter and a single output dimension 
  # consisting of a time average.
  
  # Random seeds. 
  driver_seed <- 623434
  par_true_seed <- 7854332
  obs_seed <- 5632
  
  # Observation operator (map from model outputs to observable): time averages
  # of LAI observations.
  output_names <- get_vsem_output_names()
  observed_output <- "LAI"
  lai_idx <- match(observed_output, output_names)
  
  obs_op <- function(model_outputs) {
    single_run <- (dim(model_outputs)[1] == 1L)
    lai_trajectory <- model_outputs[,,lai_idx]
    
    if(single_run) {
      lai_avg <- matrix(mean(lai_trajectory), nrow=1L)
    } else {
      lai_avg <- matrix(apply(lai_trajectory, 1, mean), ncol=1)
    }
    return(lai_avg)
  }
  
  # Ground truth parameters (differ from VSEM defaults). 
  par_true <- c(KEXT=0.42, LAR=1.6, LUE=0.006, GAMMA=0.2, tauV=1000, tauS=30000,
                tauR=1000, Av=0.3, Cv=3.4, Cs=14.0, Cr=2.6)
  
  # Parameters to calibrate. 
  par_cal_names <- "Cv"
  
  # Priors: using defaults with some modifications.
  par_prior <- get_vsem_default_priors()
  
  # Set up inverse problem. 
  inv_prob <- get_vsem_inv_prob(par_cal_names, obs_op, par_true=par_true, par_prior=par_prior,
                                sig2_method="fixed", sig2_fixed=(0.7)^2, signal_to_noise_ratio=20, 
                                driver_seed=driver_seed, par_true_seed=par_true_seed, 
                                obs_seed=obs_seed)
  
  # Define exact log-likelihood object. 
  llik_exact <- llikEmulatorExactGaussDiag(llik_lbl="exact", fwd_model=inv_prob$par_to_obs_op, 
                                           fwd_model_vectorized=inv_prob$par_to_obs_op,
                                           y_obs=inv_prob$y, dim_par=as.integer(inv_prob$dim_par),
                                           sig2=inv_prob$sig2_model,
                                           par_names=inv_prob$par_names, 
                                           default_conditional=default_conditional, 
                                           default_normalize=default_normalize)
  inv_prob$llik_obj <- llik_exact
  
  return(inv_prob)
}

get_vsem_test_1d_traj <- function(default_conditional=FALSE, 
                                  default_normalize=TRUE) {
  # The same example as `get_vsem_test_1d_traj()` except that the observable
  # is the entire LAI trajectory instead of a time-average of LAI. The single
  # input parameter is the initial condition for above-ground vegetation.
  # This example was designed for testing forward model emulation using a basis
  # expansion of the output space.
  
  # Random seeds. 
  driver_seed <- 623434
  par_true_seed <- 7854332
  obs_seed <- 5632
  
  # Observation operator (map from model outputs to observable): time averages
  # of LAI observations.
  output_names <- get_vsem_output_names()
  observed_output <- "LAI"
  lai_idx <- match(observed_output, output_names)
  
  obs_op <- function(model_outputs) {
    single_run <- (dim(model_outputs)[1]==1L)
    lai_trajectory <- model_outputs[,,lai_idx]
    if(single_run) lai_trajectory <- matrix(lai_trajectory, nrow=1L)
    lai_trajectory
  }
  
  # Ground truth parameters (differ from VSEM defaults). 
  par_true <- c(KEXT=0.42, LAR=1.6, LUE=0.006, GAMMA=0.2, tauV=1000, tauS=30000,
                tauR=1000, Av=0.3, Cv=3.4, Cs=14.0, Cr=2.6)
  
  # Parameters to calibrate. 
  par_cal_names <- "Cv"
  
  # Priors: using defaults with some modifications.
  par_prior <- get_vsem_default_priors()
  
  # Set up inverse problem. 
  inv_prob <- get_vsem_inv_prob(par_cal_names, obs_op, par_true=par_true, 
                                par_prior=par_prior, sig2_method="fixed", 
                                sig2_fixed=(0.7)^2, signal_to_noise_ratio=20, 
                                driver_seed=driver_seed, 
                                par_true_seed=par_true_seed, 
                                obs_seed=obs_seed)
  
  # Define exact log-likelihood object. 
  llik_exact <- llikEmulatorExactGaussDiag(llik_lbl="exact", 
                                           fwd_model=inv_prob$par_to_obs_op, 
                                           fwd_model_vectorized=inv_prob$par_to_obs_op,
                                           y_obs=inv_prob$y, 
                                           dim_par=as.integer(inv_prob$dim_par),
                                           sig2=inv_prob$sig2_model,
                                           par_names=inv_prob$par_names, 
                                           default_conditional=default_conditional, 
                                           default_normalize=default_normalize)
  inv_prob$llik_obj <- llik_exact
  
  return(inv_prob)
}








