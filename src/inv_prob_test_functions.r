#
# inv_prob_test_functions.r
# Convenience functions related to the definition of the components defining
# a Bayesian inverse problem (forward model, prior distribution, etc.).
#
# Andrew Roberts
#

library(assertthat)
library(BayesianTools) # For the VSEM toy model.

# -----------------------------------------------------------------------------
# Very Simple Ecosystem Model (VSEM):
#
# The VSEM model in the BayesianTools R package provides a convenient toy 
# example of an ecosystem model that is very fast/simple, but mimics the 
# general strcture of more complicated models. The functions here are 
# wrappers around the BayesianTools code that provide the functionality 
# to quickly define a forward model/inverse problem based on the VSEM 
# model. 
# -----------------------------------------------------------------------------

get_vsem_par_names <- function() {
  # Returns a character vector of the VSEM parameter names as specified by 
  # the BayesianTools `VSEMgetDefaults()` function. The order of the 
  # names in the returned vector is meant to establish the "official" 
  # parameter order in tests using the VSEM model. 
  
  rownames(BayesianTools::VSEMgetDefaults())
}

get_vsem_output_names <- function() {
  # Returns a character vector of the output variables returned by the 
  # VSEM forward model `fwd_vsem()` or forward models returned by 
  # `get_vsem_fwd_model()`. Note that this includes the variables 
  # returned by the BayesianTools `VSEM()` function in addition to 
  # variables that are added by the wrapper functions defined here; 
  # e.g., Leaf Area Index (LAI). Analogous to `get_vsem_par_names()`, 
  # the character vector returned here is meant to establish an 
  # official output variable order. 
  
  c("NEE", "Cv", "Cs", "CR", "LAI")
  
}

get_vsem_default_pars <- function() {
  # A convenience function returning default parameters for the VSEM parameters,
  # following the parameter order convention specified by `get_vsem_par_names()`.
  # Currently, this uses the values given in the "best" column of the data.frame 
  # returned by BayesianTools' `VSEMgetDefaults()` but this could conceivably 
  # change if defaults differing from those specified by BayesianTools are 
  # desired. 
  par_name_order <- get_vsem_par_names()
  BayesianTools::VSEMgetDefaults()[par_name_order, "best"]
}

get_vsem_default_priors <- function() {
  # A convenience function to return default priors for the VSEM model
  # parameters, including the initial conditions. Note that this does not
  # align with the bounds provided in the R BayesianTools function
  # `VSEMgetDefaults()`.
  
  # Default priors.
  par_priors <- list()
  par_priors$par_name <- c("KEXT","LAR","LUE","GAMMA","tauV","tauS","tauR",
                           "Av","Cv","Cs","Cr")
  par_priors$dist <- rep("Uniform", length(par_priors$par_name))
  par_priors$param1 <- c(2e-01,2e-01,5e-04,2e-01,5e+02,4e+03,5e+02,2e-01,0.0,0.0,0.0)
  par_priors$param2 <- c(1.0,3.0,4e-03,6e-01,3e+03,5e+04,3e+03,1.0,10.0,30.0,10.0)
  par_priors <- as.data.frame(par_priors)

  # Ensure parameter names/order is correct. 
  vsem_par_name_order <- get_vsem_par_names()
  assert_that(all(vsem_par_name_order==par_priors$par_name))

  return(par_priors)
}


solve_vsem <- function(driver, par) {
  # A wrapper around BayesianTools' function `VSEM()` which implements a 
  # simple Euler discretization of the VSEM ordinary differential 
  # equation. The main purpose of this wrapper is to add on additional 
  # output variables to the variables returned by `VSEM()`. 
  #
  # Args:
  #    driver: numeric(), vector containing the driving/forcing data for 
  #            the VSEM model. This is typically generated by calling 
  #            `BayesianTools::VSEMcreatePAR()`. The length of this 
  #            vector determines the number of time points in the 
  #            discretization and hence the number of rows in the matrix
  #            returned by `solve_vsem()`. 
  #   par: numeric(), vector containing the parameter values to 
  #        use. Must contain values for all VSEM parameters in 
  #        the correct order, as required by BayesianTools. 
  #
  # Returns: 
  #    matrix of shape (N_time, N_output) where `N_time` is the number 
  #    of time points at which the VSEM solution was approximated 
  #    and `N_output` is the number of output variables. The output 
  #    variables are sorted according to `get_vsem_output_names()`. 
  
  output_var_order <- get_vsem_output_names()
  par_names_order <- get_vsem_par_names()
  
  # VSEM output. 
  vsem_output <- VSEM(pars=par, PAR=driver)
  
  # Augment output by computing Leaf Area Index (LAI) trajectory. 
  lai_idx <- which(par_names_order=="LAR")
  lai_trajectory <- par[lai_idx] * vsem_output[,"Cv"]
  vsem_output <- cbind(vsem_output, LAI=lai_trajectory)
  
  assert_that(all(output_var_order==colnames(vsem_output)))
  return(vsem_output)
  
}


fwd_vsem <- function(par_cal, driver, par_cal_idx=NULL, par_default=NULL, simplify=TRUE) {
  # A convenience function defining a "forward map" for the VSEM model. This is
  # map from the calibration parameter (which includes initial conditions)
  # to the model outputs, which are the simulated trajectories of the
  # output variables. Note that the calibration parameters often represent a
  # subset of the set of 11 VSEM parameters. If this is the case, then
  # `par_cal_idx` must be specified, which is an array giving the indices
  # of the calibration parameters within the 11-dimensional full parameter
  # vector. In this case, the values of the calibration parameters will be set
  # to `par_cal`, while the values of the remaining "fixed" parameters are
  # set to those specified in `par_default`. If `par_default` is NULL, then
  # it is set to `get_vsem_default_pars()`. Note that `par_default` must
  # be a vector of length 11, containing ALL of the parameters. `par_cal` will
  # replace the values of the calibration parameters within this vector.
  # Finally, note that `fwd_vsem()` is vectorized so that multiple runs can
  # be conducted at different values of the calibration parameters. In this
  # case `par_cal` should be a matrix of dimension (N_runs, N_cal), where
  # N_cal is the number of calibration parameters. For a single run, a
  # matrix of shape (1,N_cal) or a `N_cal` length vector is allowed. 
  # For now, the same default values for the fixed parameters are used 
  # across all runs, but this could change in the future. Note that 
  # `get_vsem_par_names()` defines the official ordering for the VSEM 
  #
  # Returns:
  # An array of shape (N_runs, N_time_step, N_outputs). If there is 
  # is only 1 run and `simplify` is TRUE, then the output dimension 
  # is simplified to (N_time_step, N_outputs). 

  # Ensure `par_cal` dimension is consistent with single run or multiple runs.
  if(is.vector(par_cal)) {
    par_cal <- matrix(par_cal, nrow=1)
  } else if(!is.matrix(par_cal)) {
    stop("`par_cal` must be a numeric vector or a matrix.")
  }
  
  # If the set of calibration parameters is a subset of all VSEM parameters,
  # ensure that `par_cal_idx` is provided, and define defaults for the parameters
  # being fixed.
  par_names <- get_vsem_par_names()
  n_par_vsem = length(par_names)
  n_par_cal <- ncol(par_cal)
  par_cal_is_subset <- TRUE
  if(n_par_cal < n_par_vsem) {
    assert_that(!is.null(par_cal_idx), 
                msg="`par_cal_idx` is NULL but `n_par_cal < n_par_vsem`")
    assert_that(length(par_cal_idx)==n_par_cal)
    if(is.null(par_default)) par_default <- get_vsem_default_pars()
    else assert_that(length(par_default)==n_par_vsem)
  } else if(n_par_cal > n_par_vsem) {
    stop("Number of calibration parameters exceeds number of VSEM parameters.")
  } else {
    par_cal_is_subset <- FALSE 
  }
  
  # Execute forward model evaluations. For now this is done in a loop, but
  # parallelization may be added in the future.
  vsem_output_names <- get_vsem_output_names()
  n_time_step <- length(driver)
  n_run <- nrow(par_cal)
  n_output = length(vsem_output_names)
  model_output <- array(NA_real_, dim=c(n_run,n_time_step,n_output))
  
  for(i in 1:n_run) {
    if(par_cal_is_subset) {
      par_run <- par_default
      par_run[par_cal_idx] <- par_cal[i,]
    } else {
      par_run <- par_cal[i,]
    }
    model_output[i,,] <- solve_vsem(driver, par_run)
  }
  
  # Optionally simplify dimension for the single-run case.
  if((n_run==1) && simplify) model_output <- model_output[1,,]

  return(model_output)
  
}


get_vsem_fwd_model <- function(driver, n_par_cal, par_cal_idx=NULL, 
                               par_default=NULL, simplify=TRUE) {
  # A convenience function that returns a function representing the VSEM
  # forward model `fwd_vsem()` but only as an argument of `par_cal`, with the
  # remaining arguments fixed. This is convenient for parameter estimation
  # analyses where the remaining arguments (e.g., the model driver and the 
  # fixed parameters) will be fixed throughout the analysis. Also includes 
  # a check to ensure the parameter dimension is correct.
    
  fwd <- function(par_cal) {
    if(is.vector(par_cal)) assert_that(length(par_cal)==n_par_cal)
    else assert_that(ncol(par_cal)==n_par_cal)
    
    return(fwd_vsem(par_cal, driver, par_cal_idx, par_default, simplify))
  }
  
  return(fwd)
}








