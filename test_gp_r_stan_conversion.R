# test_gp_r_stan_conversion.R
# Tests the Gaussian Process (GP) Stan functions by comparing their output to 
# that of supported GP packages in R. The Stan functions assume a fixed form 
# of the Gaussian covariance function, which may differ from the exact 
# parameterization used by various R packages. This file tests that the 
# parameterizations are correctly mapped. 
#
# Andrew Roberts

# TODO:
#   1.) Compare Stan function gp_approx() to function defined in R (as in likelihood comparison script).
#   2.) Ensure model interpolates when nugget is zero and predictive variance is equal to nugget at design points.

library(rstan)
library(mlegp)

options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)

source("stan.helper.functions.R")

# -----------------------------------------------------------------------------
# Generate Test Data: Toy example
# -----------------------------------------------------------------------------

# Dimension of input space
k <- 2

# Design points
nx <- 20
x <- seq(0, 2*pi, length = nx)
X.df <- expand.grid(x, x)
X <- as.matrix(X.df)
y <- sin(X[,1] + 4*X[,2])
N <- length(y)

# Test points
N.pred.x <- 30
x.pred <- seq(-0.5, 2*pi + 0.5, length = N.pred.x)
X.pred.df <- expand.grid(x.pred, x.pred)
X.pred <- as.matrix(X.pred.df)
N.pred <- nrow(X.pred)

# Plot test data (will only work if k = 1)
# matplot(X, y, pch = 20, cex = 2, xlab = 'Design Points', ylab = 'Model Value')


# -----------------------------------------------------------------------------
# R package: mlegp
# -----------------------------------------------------------------------------

# Fit GP model
gp.mlegp <- mlegp(X, y, nugget.known = 0, constantMean = 1)

# Map kernel parameters to Stan parameterization
gp.stan.params <- create.gp.params.list(gp.mlegp, "mlegp")

# Compile and run Stan code
stan.model.path <- "test_gp_r_stan_conversion.stan"
model <- stan_model(stan.model.path)

stan.list <- as.list(c(gp.stan.params, 
                       list(N = N, 
                            N_pred = N.pred, 
                            k = k,
                            X = X, 
                            y = as.vector(y), 
                            X_pred = X.pred)))

stan.fit <- sampling(model, data = stan.list, warmup = 0, iter = 1, chains = 1, 
                     seed = 494838, refresh = 4000, algorithm = "Fixed_param")
stan.output <- extract(stan.fit)
                     

# Test the covariance matrix generated by the design points
K.mlegp <- calcVarMatrix(X, gp.mlegp$beta, gp.mlegp$a, gp.mlegp$nugget, gp.mlegp$sig2, 0, gp.mlegp$numObs)
K.stan <- stan.output$K_out[1,,]
print(paste0("Cov matrices K(X) equal: ", all.equal(K.mlegp, K.stan)))

# Test the covariance matrix generated by the test/prediction points
K.pred.mlegp <- calcVarMatrix(X.pred, gp.mlegp$beta, gp.mlegp$a, gp.mlegp$nugget, gp.mlegp$sig2, 0, N.pred)
K.pred.stan <- stan.output$K_pred[1,,]
print(paste0("Cov matrices K(X_pred) equal: ", all.equal(K.pred.mlegp, K.pred.stan)))

# Test the covariances between the design and prediction points
K.cross.mlegp <- matrix(NA, nrow = N, ncol = N.pred)
for(j in seq(1, N.pred)) {
  K.cross.mlegp[,j] <- gp.mlegp$sig2 * calcCorOneObs(X, gp.mlegp$beta, gp.mlegp$a, X.pred[j,])
}

K.cross.stan <- stan.output$K_cross[1,,]
print(paste0("Cov matrices K(X, X_pred) equal: ", all.equal(K.cross.mlegp, K.cross.stan)))

# Test that mean prediction gives same results
gp.pred.mlegp <- predict(gp.mlegp, newData = X.pred)
gp.pred.stan <- t(stan.output$mean_pred)
print(paste0("Max absolute error in mean predictions: ", max(abs(gp.pred.mlegp - gp.pred.stan))))

# Test variance predictions
gp.var.mlegp <- predict(gp.mlegp, X.pred, se.fit = TRUE)$se.fit^2 + gp.mlegp$nugget
gp.var.stan <- t(stan.output$var_pred)
print(paste0("Max absolute error in variance predictions: ", max(abs(gp.var.mlegp - gp.var.stan))))


# -----------------------------------------------------------------------------
# General Stan tests
# -----------------------------------------------------------------------------

# Compare user defined covariance function to Stan's internal cov_exp_quad()
K.stan.test <- stan.output$K_stan_test[1,,]
K.test <- stan.output$K_out_test[1,,]
print(paste0("Cov matrix agrees with Stan's cov_exp_quad(): ", all.equal(K.test, K.stan.test)))

# Test that predictive mean interpolates observed data (when nugget is 0). If nugget is not 0, then 
# the predictive mean will not exactly equal the observed value. 
mean.design.stan <- as.vector(stan.output$mean_design)
print(paste0("Max absolute error of mean at design points: ", max(abs(mean.design.stan - y))))

# Test that predictive variance is equal to the nugget at observed data points
var.design.stan <- as.vector(stan.output$var_design)
print(paste0("Max absolute error of variance at design points: ", max(abs(var.design.stan - gp.mlegp$nugget))))








