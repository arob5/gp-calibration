---
title: "Bayesian Optimization Tests"
author: "Andrew Roberts"
date: '2023-06-16'
output: html_document
---

```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(lhs)
library(hetGP)
library(mlegp)
library(ggplot2)
library(viridis)
library(gridExtra)
library(data.table)
library(BayesianTools)

source("numerical_experiment_functions.r")
source("mcmc_calibration_functions.r")
source("gp_emulator_functions.r")
source("sequential_design_optimization.r")
```


# Computer Model and Data 

```{r}
# Synthetic data generation
computer_model_data <- generate_vsem_test_case(4)
```

```{r}
print(computer_model_data$ref_pars[computer_model_data$pars_cal_sel,])
```

```{r echo = FALSE}
for(output_var in computer_model_data$output_vars) {
 plotTimeSeries(observed = computer_model_data$data_obs[, output_var],
                predicted = computer_model_data$data_ref[, output_var], main = output_var) 
}
```

# Priors 

## Calibration Parameters 
```{r, echo = FALSE} 
# Priors 
theta_prior_params <- computer_model_data$ref_pars[computer_model_data$pars_cal_sel,]
theta_prior_params[, "dist"] <- c("Uniform", "Uniform")
theta_prior_params[,"param1"] <- c(1.3, 0.4) # theta_prior_params[,"lower"]
theta_prior_params[,"param2"] <- c(1.7, 0.6)  # theta_prior_params[,"upper"]
theta_prior_params <- theta_prior_params[, c("dist", "param1", "param2")]

print(theta_prior_params)
```


## Likelihood Parameters 
```{r}
sig2_prior_info <- get_IG_priors_numerical_test(sig2_true = diag(computer_model_data$Sig_eps), 
                                                bias_frac = c(0.1, -0.15), bins = 50,
                                                coef_var = c(0.3, 0.5), return_prior_plots = TRUE, 
                                                output_variables = computer_model_data$output_vars)
sig_eps_prior_params <- sig2_prior_info$prior
plts <- sig2_prior_info$plots

grid.arrange(arrangeGrob(grobs = plts, nrow = 1))
```

# Exact MCMC Samples.

## Exact MCMC. 
```{r}
N_mcmc_exact <- 50000

time_start <- proc.time()
samp_mcmc_exact <- mcmc_calibrate_product_lik(computer_model_data = computer_model_data, 
                                              theta_prior_params = theta_prior_params, 
                                              learn_sig_eps = TRUE,
                                              sig_eps_prior_params = sig_eps_prior_params,
                                              N_mcmc = N_mcmc_exact)
mcmc_exact_runtime <- (proc.time() - time_start)[["elapsed"]]

samp_exact_df <- as.data.frame(samp_mcmc_exact$samp)
colnames(samp_exact_df) <- paste("exact", colnames(samp_exact_df), sep = "_")

print(paste0("Exact MCMC runtime: ", mcmc_exact_runtime, " seconds."))
```

```{r}
burn_in_exact <- c(exact = 10000)

mcmc_exact_trace_plts <- get_trace_plots(samp_exact_df, burn_in_start = burn_in_exact, param_types = "theta")
grid.arrange(arrangeGrob(grobs = mcmc_exact_trace_plts, nrow = 1))
```

```{r}
mcmc_exact_trace_plts_sig_eps <- get_trace_plots(samp_exact_df, burn_in_start = burn_in_exact, param_types = "sig_eps")
grid.arrange(arrangeGrob(grobs = mcmc_exact_trace_plts_sig_eps, nrow = 1))
```

```{r}
samp_exact_theta <- as.matrix(samp_exact_df[burn_in_exact:N_mcmc_exact, c("exact_theta_LAR", "exact_theta_KEXT")])
colnames(samp_exact_theta) <- c("LAR", "KEXT")
```


# Fit GP on initial space-filling design. 

```{r, echo = FALSE}
# Emulator settings
emulator_settings <- data.frame(gp_lib = c("hetGP"), 
                                kernel = "Gaussian", 
                                transformation_method = c("truncated"),
                                scale_X = TRUE, 
                                normalize_y = TRUE)
print(emulator_settings)
```

```{r, echo = FALSE}
set.seed(100)

# Initial space-filling design.
design_info <- get_input_output_design(N_points = 20, 
                                       design_method = "LHS", 
                                       computer_model_data = computer_model_data, 
                                       theta_prior_params = theta_prior_params, 
                                       transformation_method = emulator_settings$transformation_method)

# Grid based on prior bounds for producing heatmaps. Ensure same scaling as design points. 
prior_grid_info <- get_input_output_design(N_points = 51^2,
                                           design_method = "grid", 
                                           scale_inputs = TRUE,
                                           param_ranges = design_info$input_bounds,
                                           computer_model_data = computer_model_data, 
                                           theta_prior_params = theta_prior_params, 
                                           transformation_method = emulator_settings$transformation_method)

```

```{r}
# Plot initial design overlaid on true posterior. Ensure same scaling on all inputs. 
init_design_plt <- get_2d_response_surface_plot(computer_model_data = computer_model_data, 
                                                theta_vals = prior_grid_info$inputs, 
                                                param_names = computer_model_data$pars_cal_names, 
                                                response_surface = "posterior", 
                                                SSR_vals = prior_grid_info$outputs, 
                                                raster = TRUE, 
                                                point_coords = computer_model_data$theta_true,
                                                samples_kde = samp_exact_theta, 
                                                samples_points = design_info$inputs,
                                                scale_inputs = TRUE, 
                                                input_bounds = design_info$input_bounds,
                                                theta_prior_params = theta_prior_params)
                                                

plot(init_design_plt)
```

## Fit GP. 
```{r}
gp_fits <- fit_independent_GPs(X_train = design_info$inputs_scaled, 
                               Y_train = design_info$outputs_normalized, 
                               gp_lib = emulator_settings$gp_lib, 
                               gp_kernel = emulator_settings$kernel)$fits
    
emulator_info_list <- list(gp_fits = gp_fits, 
                           input_bounds = design_info$input_bounds, 
                           output_stats = design_info$output_stats, 
                           settings = emulator_settings)
```


```{r}
# Predictive log posterior random field mean.  
```

```{r}
# Predictive log posterior random field variance.  
```


```{r}
# GP predictions at grid points. 
gp_pred_grid <- predict_independent_GPs(X_pred = prior_grid_info$inputs_scaled, 
                                        gp_obj_list = emulator_info_list$gp_fits, 
                                        gp_lib = emulator_info_list$settings$gp_lib, 
                                        denormalize_predictions = TRUE, 
                                        output_stats = emulator_info_list$output_stats, 
                                        transformation_method = emulator_info_list$settings$transformation_method, 
                                        output_variables = computer_model_data$output_vars)
```


```{r}
# Draw samples from log posterior random field over grid points. 
lpost_GP_samp_grid <- samp_GP_lpost_theta(theta_vals = prior_grid_info$inputs, 
                                          emulator_info_list = emulator_info_list, 
                                          computer_model_data = computer_model_data, 
                                          theta_prior_params = theta_prior_params, 
                                          sig2_eps = diag(computer_model_data$Sig_eps), 
                                          N_samples = 100, 
                                          gp_pred_list = gp_pred_grid) 
```

```{r}
# Monte Carlo approximation of predictive log posterior random field mean. 
lpost_MC_mean_plt <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                         y = colMeans(lpost_GP_samp_grid), 
                                         param_names = computer_model_data$pars_cal_names, 
                                         samples_kde = samp_exact_theta, 
                                         samples_points = design_info$inputs,  
                                         raster = TRUE, 
                                         point_coords = computer_model_data$theta_true, 
                                         main_title = "Log Posterior Predictive Mean (Monte Carlo approximation)", 
                                         bigger_is_better = TRUE, 
                                         legend_label = "lpost Approx Mean")
plot(lpost_MC_mean_plt)
```


```{r}
# Monte Carlo approximation of predictive log posterior random field variance. 

lpost_MC_var_plt <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                        y = sqrt(apply(lpost_GP_samp_grid, 2, var)), 
                                        param_names = computer_model_data$pars_cal_names, 
                                        samples_kde = samp_exact_theta, 
                                        samples_points = design_info$inputs,  
                                        raster = TRUE, 
                                        point_coords = computer_model_data$theta_true, 
                                        main_title = "Log Posterior Predictive SD (MC approximation)", 
                                        bigger_is_better = TRUE, 
                                        legend_label = "SD", 
                                        log_scale = TRUE)
plot(lpost_MC_var_plt)
```

## Expected Improvement Acquisition 
```{r}

# Current minimum observed lpost value. 
lpost_design <- calc_lpost_theta_product_lik(theta_vals = design_info$inputs, 
                                             computer_model_data = computer_model_data, 
                                             SSR = design_info$outputs, 
                                             vars_obs = diag(computer_model_data$Sig_eps), 
                                             na.rm = TRUE, 
                                             return_list = FALSE,
                                             theta_prior_params = theta_prior_params)
lpost_max <- max(lpost_design)

# Approximate Expected Improvement acquisition over grid of points. 
EI_MC_est <- acquisition_EI_MC(theta_vals = prior_grid_info$inputs,
                               emulator_info_list = emulator_info_list, 
                               lpost_max = lpost_max, 
                               computer_model_data = computer_model_data, 
                               theta_prior_params = theta_prior_params, 
                               sig2_eps = diag(computer_model_data$Sig_eps), 
                               gp_pred_list = gp_pred_grid, 
                               N_MC_samples = 100)

# Approximate Probability of Improvement acquisition over grid of points. 
PI_MC_est <- acquisition_EI_MC(theta_vals = prior_grid_info$inputs,
                               emulator_info_list = emulator_info_list, 
                               lpost_max = lpost_max, 
                               computer_model_data = computer_model_data, 
                               theta_prior_params = theta_prior_params, 
                               sig2_eps = diag(computer_model_data$Sig_eps), 
                               gp_pred_list = gp_pred_grid, 
                               N_MC_samples = 100)
```

```{r}
# Monte Carlo approximation of Expected Improvement acquisition over grid points.  
EI_MC_plt <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                 y = EI_MC_est, 
                                 param_names = computer_model_data$pars_cal_names, 
                                 samples_kde = samp_exact_theta, 
                                 samples_points = design_info$inputs,  
                                 raster = TRUE, 
                                 point_coords = computer_model_data$theta_true, 
                                 main_title = "Expected Improvement (Monte Carlo approximation)", 
                                 bigger_is_better = TRUE, 
                                 legend_label = "EI")
plot(EI_MC_plt)
```
```{r}
# Monte Carlo approximation of Probability of Improvement acquisition over grid points.  
PI_MC_plt <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                 y = PI_MC_est, 
                                 param_names = computer_model_data$pars_cal_names, 
                                 samples_kde = samp_exact_theta, 
                                 samples_points = design_info$inputs,  
                                 raster = TRUE, 
                                 point_coords = computer_model_data$theta_true, 
                                 main_title = "Probability of Improvement (Monte Carlo approximation)", 
                                 bigger_is_better = TRUE, 
                                 legend_label = "PI")
plot(PI_MC_plt)
```

```{r}

Bayes_opt_settings <- list(N_opt_iter = 10, acquisition_type = "EI_MC", opt_method = "grid", N_MC_samples = 1000)

results <- bayes_opt_one_step(emulator_info_list = emulator_info_list,  
                              Bayes_opt_settings = Bayes_opt_settings,
                              design_input_curr = design_info$inputs, 
                              design_objective_curr = lpost_design, 
                              design_best_idx = which.max(lpost_design),
                              computer_model_data = computer_model_data, 
                              sig2_eps = diag(computer_model_data$Sig_eps), 
                              theta_prior_params = theta_prior_params, 
                              theta_grid_ref = prior_grid_info$inputs)

```


```{r}

design_settings <- list(design_method = "LHS", N_design = 20)

Bayes_opt_results <- Bayes_opt(Bayes_opt_settings = Bayes_opt_settings, 
                               init_design_settings = design_settings, 
                               emulator_settings = emulator_settings, 
                               computer_model_data = computer_model_data, 
                               sig2_eps = diag(computer_model_data$Sig_eps), 
                               theta_prior_params = theta_prior_params, 
                               theta_grid_ref = prior_grid_info$inputs) 
```

```{r}
lpost_true_theta <- calc_lpost_theta_product_lik(computer_model_data = computer_model_data, 
                                                 theta_vals = computer_model_data$theta_true, 
                                                 vars_obs = diag(computer_model_data$Sig_eps), 
                                                 na.rm = TRUE, 
                                                 theta_prior_params = theta_prior_params, 
                                                 return_list = FALSE)

BO_obj_plot <- ggplot(data = data.frame(itr = seq_along(Bayes_opt_results$best_idx), 
                                        obj = Bayes_opt_results$objective_vals[Bayes_opt_results$best_idx])) + 
               geom_point(mapping = aes(x = itr, y = obj)) + 
               geom_hline(yintercept = lpost_true_theta, col = "red") + 
               ggtitle("lpost highest observed value") + 
               xlab("Iteration") + 
               ylab("Log Posterior")
              
BO_obj_plot
```

```{r}
plt <- get_2d_Bayes_opt_heatmap_plot(theta_vals = prior_grid_info$inputs, 
                              computer_model_data = computer_model_data, 
                              param_names = computer_model_data$pars_cal_names, 
                              samples_kde = samp_exact_theta, 
                              init_design_points = Bayes_opt_results$design_inputs[1:design_settings$N_design,],  
                              sequential_design_points = Bayes_opt_results$design_inputs[(design_settings$N_design+1):nrow(Bayes_opt_results$design_inputs),], 
                              raster = TRUE, 
                              point_coords = computer_model_data$theta_true,  
                              main_title = "lpost heatmap with Bayes Opt points.", 
                              bigger_is_better = TRUE, 
                              legend_label = "lpost")
                              
plt
```

```{r}
plt <- get_2d_Bayes_opt_heatmap_plot(theta_vals = samp_exact_theta, 
                              computer_model_data = computer_model_data, 
                              param_names = computer_model_data$pars_cal_names, 
                              samples_kde = samp_exact_theta, 
                              sequential_design_points = Bayes_opt_results$design_inputs[(design_settings$N_design+1):nrow(Bayes_opt_results$design_inputs),], 
                              raster = FALSE, 
                              point_coords = computer_model_data$theta_true,  
                              main_title = "lpost heatmap with Bayes Opt points.", 
                              bigger_is_better = TRUE, 
                              legend_label = "lpost")
                              
plt
```



# Things to consider doing: 
#     - Heatmap of error metrics to track where posterior approx is good/bad. 
#     - Need to produce analogous plots to above, but not using the true likelihood parameters, 
#       which in practice are not known. 
#     - Look into local approximate GPs and Deep GPs. 
#     - Look into weighting to approx posterior to avoid the situation above. 
#     - Try to develop a CRPS objective for BayesOpt? 
#     - Think about improving the efficiency regarding scaling inputs. Currently just passing in 
#       unscaled inputs to all BayesOpt functions. 








