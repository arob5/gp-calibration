---
title: "Plots for Environmental Bayes Poster Presentation"
author: "Andrew Roberts"
date: '2023-08-28'
output: html_document
---

```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(lhs)
library(hetGP)
library(mlegp)
library(ggplot2)
library(viridis)
library(parallel)
library(gridExtra)
library(data.table)
library(BayesianTools)

source("numerical_experiment_functions.r")
source("mcmc_calibration_functions.r")
source("gp_emulator_functions.r")
source("sequential_design_optimization.r")
```

# Computer Model and Data 

```{r, include = FALSE}
# Synthetic data generation
computer_model_data <- generate_vsem_test_case(4)
```

```{r}
print(computer_model_data$ref_pars[computer_model_data$pars_cal_sel,])
```

```{r echo = FALSE}
for(output_var in computer_model_data$output_vars) {
 plotTimeSeries(observed = computer_model_data$data_obs[, output_var],
                predicted = computer_model_data$data_ref[, output_var], main = output_var) 
}
```

# Priors 

## Calibration Parameters 
```{r, echo = FALSE} 
# Priors 
theta_prior_params <- computer_model_data$ref_pars[computer_model_data$pars_cal_sel,]
theta_prior_params[, "dist"] <- c("Uniform", "Uniform")
theta_prior_params[,"param1"] <- c(1.4, 0.45) # theta_prior_params[,"lower"]
theta_prior_params[,"param2"] <- c(1.6, 0.55)  # theta_prior_params[,"upper"]
theta_prior_params <- theta_prior_params[, c("dist", "param1", "param2")]

print(theta_prior_params)
```


## Likelihood Parameters 
```{r}
sig2_prior_info <- get_IG_priors_numerical_test(sig2_true = diag(computer_model_data$Sig_eps), 
                                                bias_frac = c(0.1, -0.15), bins = 50,
                                                coef_var = c(0.3, 0.5), return_prior_plots = TRUE, 
                                                output_variables = computer_model_data$output_vars)
sig_eps_prior_params <- sig2_prior_info$prior
plts <- sig2_prior_info$plots

grid.arrange(arrangeGrob(grobs = plts, nrow = 1))
```

# Exact MCMC Samples.

## Exact MCMC. 
```{r}
N_mcmc_exact <- 50000

time_start <- proc.time()
mcmc_exact_list <- mcmc_calibrate_product_lik(computer_model_data = computer_model_data, 
                                              theta_prior_params = theta_prior_params, 
                                              learn_sig_eps = TRUE,
                                              sig_eps_prior_params = sig_eps_prior_params,
                                              N_mcmc = N_mcmc_exact)
mcmc_exact_runtime <- (proc.time() - time_start)[["elapsed"]]
print(paste0("Exact MCMC runtime: ", mcmc_exact_runtime, " seconds."))

# Format MCMC samples. 
mcmc_samp_dt <- format_mcmc_output(samp_list = mcmc_exact_list[c("theta", "sig_eps")], test_label = "exact")

```

```{r}
# TODO: write function `get_mcmc_diagnostics()`. 
burn_ins <- c(exact = 10000)

mcmc_exact_trace_plts <- get_trace_plots(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "exact", param_types = "theta")
mcmc_exact_trace_plts_sig_eps <- get_trace_plots(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "exact", param_types = "sig_eps")

grid.arrange(arrangeGrob(grobs = mcmc_exact_trace_plts, nrow = 1))
grid.arrange(arrangeGrob(grobs = mcmc_exact_trace_plts_sig_eps, nrow = 1))
```


```{r}
# Store matrix of calibration parameter samples from exact MCMC for plotting purposes. 
samp_exact_theta <- select_mcmc_samp(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "exact", param_types = "theta")[, .(param_name, sample)]
samp_exact_theta <- as.matrix(unstack(samp_exact_theta, sample ~ param_name))[, computer_model_data$pars_cal_names]
```


```{r}
# Store exact samples that will be used to compute error metrics. 

# Samples for sample-based metrics that require approximately independent samples. 
# TODO: should monitor estimated auto-correlation here. 
samp_exact_theta_thinned <- samp_exact_theta[seq(1, nrow(samp_exact_theta), 5),]

# Samples for computing emulator-based metrics. This requires computing GP predictions at every sample, so must reduce 
# the number of samples for computational feasibility. 
samp_exact_theta_emulator_metrics <- samp_exact_theta[seq(1, nrow(samp_exact_theta), 10),]

```


# Round 0: Fit GP on initial space-filling design. 

```{r, echo = FALSE}
# Emulator settings
emulator_settings <- data.frame(gp_lib = c("hetGP"), 
                                kernel = "Gaussian", 
                                transformation_method = c("truncated"),
                                emulator_target = "SSR",
                                scale_X = TRUE, 
                                normalize_y = TRUE)
print(emulator_settings)
```

```{r}
# Initial design (round 0). 
design_settings <- data.frame(N_design = 15, design_method = "LHS", design_seed = 5)
init_design_info <- get_input_output_design(N_points = design_settings$N_design,
                                            design_method = design_settings$design_method, 
                                            scale_inputs = TRUE,
                                            computer_model_data = computer_model_data, 
                                            theta_prior_params = theta_prior_params)

# Grid of points spread across prior (for plotting).  
prior_grid_info <- get_input_output_design(N_points = 51^2,
                                           design_method = "grid", 
                                           scale_inputs = TRUE,
                                           param_ranges = init_design_info$input_bounds,
                                           computer_model_data = computer_model_data, 
                                           theta_prior_params = theta_prior_params, 
                                           design_seed = design_settings$design_seed)
prior_grid_info$lpost <- calc_lpost_theta_product_lik(computer_model_data = computer_model_data, 
                                                      theta_vals = prior_grid_info$inputs, 
                                                      vars_obs = diag(computer_model_data$Sig_eps), 
                                                      SSR = prior_grid_info$outputs,
                                                      na.rm = TRUE, theta_prior_params = theta_prior_params, 
                                                      return_list = FALSE)
```

```{r}
# Plot initial design. 
# TODO: change axis labels to theta1 and theta2 or something generic like that. 

plt_init_design <- get_2d_heatmap_plot(X = prior_grid_info$inputs, y = prior_grid_info$lpost, param_names = computer_model_data$pars_cal_names, 
                                       samples_kde = samp_exact_theta, samples_points = init_design_info$inputs, raster = TRUE, 
                                       bigger_is_better = TRUE, main_title = "Initial Design and Heatmap of True Posterior")
                                       
plot(plt_init_design)


```

```{r}
# Fix pre-MCMC estimates of calibration and likelihood parameters based on design data. 
init_estimates <- get_init_param_estimates(init_design_info, computer_model_data, sig_eps_prior_params)
init_design_info$init_estimates <- init_estimates
print("Initial Estimates:")
print(init_estimates)
```


```{r}
# Fit emulators on initial design. 
gp_fits <- fit_independent_GPs(X_train = init_design_info$inputs_scaled, Y_train = init_design_info$outputs_normalized, 
                               gp_lib = emulator_settings$gp_lib, gp_kernel = emulator_settings$kernel)$fits
emulator_info_list <- list(gp_fits = gp_fits, input_bounds = init_design_info$input_bounds, 
                           output_stats = init_design_info$output_stats, settings = emulator_settings)

# Induced log joint density (i.e. log unnormalized posterior density) emulator. 
lpost_emulator <- get_lpost_emulator_obj(emulator_info_list = emulator_info_list, design_info_list = init_design_info, 
                                         computer_model_data = computer_model_data, sig2_eps = init_design_info$init_estimates$best_sig2_eps, 
                                         theta_prior_params = theta_prior_params, center_output = TRUE, scale_output = TRUE)

lpost_emulator_no_scale <- get_lpost_emulator_obj(emulator_info_list = emulator_info_list, design_info_list = init_design_info, 
                                                  computer_model_data = computer_model_data, sig2_eps = init_design_info$init_estimates$best_sig2_eps, 
                                                  theta_prior_params = theta_prior_params, center_output = TRUE, scale_output = FALSE)
```


```{r}
#
# Compute round 0 emulator-based metrics.  
#

# # Validation data for evaluating emulator-based metrics. 
# lpost_emulator_metrics <- calc_lpost_theta_product_lik(computer_model_data = computer_model_data, 
#                                                        theta_vals = samp_exact_theta_emulator_metrics, 
#                                                        vars_obs = diag(computer_model_data$Sig_eps), 
#                                                        na.rm = TRUE, theta_prior_params = theta_prior_params, 
#                                                        return_list = FALSE)
# 
# val_data_emulator_metrics <- list(inputs = samp_exact_theta_emulator_metrics, 
#                                   inputs_scaled = scale_input_data(samp_exact_theta_emulator_metrics, init_design$input_bounds), 
#                                   outputs = lpost_emulator_metrics)
# 
# # Compute metrics. 
# metrics_results <- get_lpost_emulator_metrics(lpost_emulator = lpost_emulator, 
#                                               lpost_validation_inputs = val_data_emulator_metrics$inputs, 
#                                               lpost_validation_inputs_scaled = val_data_emulator_metrics$inputs_scaled,
#                                               lpost_validation_outputs = val_data_emulator_metrics$outputs,
#                                               metrics = c("crps", "rmse"),  
#                                               include_nugget = TRUE)
# emulator_metrics_results <- data.frame(as.list(metrics_results))
# emulator_metrics_results$round <- 0
```


## Sample approximate posterior. 
```{r}
#
# Round 0 approximate posterior sampling. 
#

N_mcmc_approx <- 50000

mcmc_approx_round0 <- mcmc_calibrate_ind_GP(computer_model_data = computer_model_data, 
                                            theta_prior_params = theta_prior_params, 
                                            emulator_info = lpost_emulator$emulator_info_list,
                                            theta_init = init_design_info$init_estimates$best_input[1,], 
                                            sig_eps_init = init_design_info$init_estimates$best_sig2_eps, 
                                            learn_sig_eps = TRUE, 
                                            sig_eps_prior_params = sig_eps_prior_params, 
                                            N_mcmc = N_mcmc_approx)
```

```{r}
# Combine with existing data.table of MCMC output. 
mcmc_samp_dt <- rbindlist(list(mcmc_samp_dt, format_mcmc_output(samp_list = mcmc_approx_round0[c("theta", "sig_eps")], test_label = "round0")), 
                          use.names = TRUE)
```

### Round 0 MCMC sampling diagnostics. 
```{r}

burn_ins <- c(burn_ins, round0 = 10000)

mcmc_round0_trace_plts <- get_trace_plots(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "round0", param_types = "theta")
mcmc_round0_trace_plts_sig_eps <- get_trace_plots(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "round0", param_types = "sig_eps")

grid.arrange(arrangeGrob(grobs = mcmc_round0_trace_plts, nrow = 1))
grid.arrange(arrangeGrob(grobs = mcmc_round0_trace_plts_sig_eps, nrow = 1))
```


```{r}
#
# Store round 0 MCMC approximate posterior samples. These are used as candidate/integration points for sequential design, 
# as well as for plotting purposes. 
#

samp_round0_theta <- select_mcmc_samp(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "round0", param_types = "theta")[, .(param_name, sample)]
samp_round0_theta <- as.matrix(unstack(samp_round0_theta, sample ~ param_name))[, computer_model_data$pars_cal_names]

samp_round0_sig_eps <- select_mcmc_samp(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "round0", param_types = "sig_eps")[, .(param_name, sample)]
samp_round0_sig_eps <- as.matrix(unstack(samp_round0_sig_eps, sample ~ param_name))[, computer_model_data$output_vars]

SSR_round0 <- get_computer_model_SSR(computer_model_data = computer_model_data, theta_vals = samp_round0_theta, na.rm = TRUE)
lpost_round0_outputs <- calc_lpost_theta_product_lik(computer_model_data = computer_model_data, 
                                                     theta_vals = samp_round0_theta, 
                                                     SSR = SSR_round0, 
                                                     vars_obs = lpost_emulator$sig2_eps, 
                                                     theta_prior_params = theta_prior_params)
samp_round0_info <- list(inputs = samp_round0_theta, 
                         inputs_scaled = scale_input_data(samp_round0_theta, init_design_info$input_bounds), 
                         outputs = lpost_round0_outputs$lpost)

# lpost emulator predictions at sampled points. 
lpost_emulator_pred_round0 <- predict_lpost_emulator(lpost_emulator = lpost_emulator, 
                                                     inputs_new_scaled = samp_round0_info$inputs_scaled, 
                                                     inputs_new_unscaled = samp_round0_info$inputs, include_nugget = TRUE, 
                                                     denormalize = FALSE)
```


```{r}
# Compute "sample-based metrics"; that is, measures of error between the approximate and true posterior computed from the MCMC samples. 

# round0_sample_metrics <- compute_mcmc_comparison_metrics(samp_dt = mcmc_samp_dt, burn_in_start = burn_ins, 
#                                                          test_label_1 = "exact", test_label_2 = "round0", 
#                                                          param_types = c("theta", "sig_eps"), 
#                                                          metrics = c("mean", "cov"))
# print(round0_sample_metrics$metrics_individual)
# print(round0_sample_metrics$metrics_agg)
```

```{r}
# Contours of round 1 approximate posterior vs true contours. 
# TODO: need to modify plot legend here. Also consider overlaying design points. 
post_comparison_plts_round0 <- get_overlaid_2d_density_contour_plot(samp_baseline = samp_exact_theta, samp_overlay = samp_round0_info$inputs, 
                                                                    main_title = "Round 0 Posterior Approximation")

plot(post_comparison_plts_round0)
```


```{r}
# GP predictive mean and variance plots. 

plt_mean <- get_2d_heatmap_plot(X = samp_round0_info$inputs, y = lpost_emulator_pred_round0$mean, param_names = computer_model_data$pars_cal_names, 
                                samples_kde = samp_exact_theta, raster = FALSE, 
                                samples_points = init_design_info$inputs, 
                                bigger_is_better = TRUE, 
                                main_title = "lpost predictive mean")
plt_var <- get_2d_heatmap_plot(X = samp_round0_info$inputs, y = lpost_emulator_pred_round0$var, param_names = computer_model_data$pars_cal_names, 
                               samples_kde = samp_exact_theta, raster = FALSE, 
                               samples_points = init_design_info$inputs, 
                               bigger_is_better = TRUE, log_scale = TRUE, main_title = "lpost predictive var")

plot(plt_mean)
plot(plt_var)
```
# Investigating Single-Point Acquisitions 

## Integrated Variance Acquisitions
```{r}
# Prior-Weighted 
# NOTE: plotting negative of IVAR vals to avoid negatives to produce more intuitive plots. 
# TODO: should probably also keep consistent color scheme (i.e. yellow = bigger)

# Evaluate Acquisitions. 
IVAR_lpost_grid_prior_wt <- acquisition_EIVAR_lpost(theta_vals = prior_grid_info$inputs_scaled, 
                                                    lpost_emulator = lpost_emulator, 
                                                    theta_grid_integrate = prior_grid_info$inputs_scaled, 
                                                    verbose = FALSE, include_nugget = TRUE)

IVAR_post_grid_prior_wt <- acquisition_IVAR_post(theta_vals = prior_grid_info$inputs_scaled, 
                                                 lpost_emulator = lpost_emulator, 
                                                 theta_grid_integrate = prior_grid_info$inputs_scaled, 
                                                 verbose = FALSE, include_nugget = TRUE)

# Optimizers of acquisitions. 
IVAR_lpost_grid_prior_wt_best_idx <- which.max(IVAR_lpost_grid_prior_wt)
IVAR_post_grid_prior_wt_best_idx <- which.max(IVAR_post_grid_prior_wt)
  
# Generate Plots. 
IVAR_lpost_grid_prior_wt_plot <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                                     y = -IVAR_lpost_grid_prior_wt, param_names = computer_model_data$pars_cal_names, 
                                                     samples_kde = samp_exact_theta, raster = TRUE, 
                                                     samples_points = init_design_info$inputs, 
                                                     bigger_is_better = FALSE, 
                                                     point_coords = prior_grid_info$inputs[IVAR_lpost_grid_prior_wt_best_idx,],
                                                     main_title = "IVAR-lpost, prior weighted", point_coords_col = "black")
IVAR_post_grid_prior_wt_plot <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                                    y = -IVAR_post_grid_prior_wt, param_names = computer_model_data$pars_cal_names, 
                                                    samples_kde = samp_exact_theta, raster = TRUE, 
                                                    samples_points = init_design_info$inputs, 
                                                    bigger_is_better = FALSE, 
                                                    point_coords = prior_grid_info$inputs[IVAR_post_grid_prior_wt_best_idx,],
                                                    main_title = "IVAR-post, prior weighted", point_coords_col = "black")

plot(IVAR_lpost_grid_prior_wt_plot)
plot(IVAR_post_grid_prior_wt_plot)

```

```{r}

IVAR_post_grid_prior_wt2 <- acquisition_IVAR_post(theta_vals = prior_grid_info$inputs_scaled, 
                                                  lpost_emulator = lpost_emulator_test, 
                                                  theta_grid_integrate = prior_grid_info$inputs_scaled, 
                                                  verbose = FALSE, include_nugget = TRUE)
IVAR_post_grid_prior_wt_best_idx2 <- which.max(IVAR_post_grid_prior_wt2)

IVAR_post_grid_prior_wt_plot2 <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                                     y = -IVAR_post_grid_prior_wt2, param_names = computer_model_data$pars_cal_names, 
                                                     samples_kde = samp_exact_theta, raster = TRUE, 
                                                     samples_points = init_design_info$inputs, 
                                                     bigger_is_better = FALSE, 
                                                     point_coords = prior_grid_info$inputs[IVAR_post_grid_prior_wt_best_idx,],
                                                     main_title = "IVAR-post, prior weighted", point_coords_col = "black")


grid_pred <- predict_lpost_emulator(inputs_new_scaled = prior_grid_info$inputs_scaled, lpost_emulator = lpost_emulator, unscale = FALSE, uncenter = FALSE)

plt_mean <- get_2d_heatmap_plot(X = prior_grid_info$inputs, y = grid_pred$mean, param_names = computer_model_data$pars_cal_names, 
                                samples_kde = samp_exact_theta, raster = TRUE, 
                                samples_points = init_design_info$inputs, 
                                bigger_is_better = TRUE, 
                                main_title = "lpost predictive mean")
plt_var <- get_2d_heatmap_plot(X = prior_grid_info$inputs, y = grid_pred$var, param_names = computer_model_data$pars_cal_names, 
                               samples_kde = samp_exact_theta, raster = TRUE, 
                               samples_points = init_design_info$inputs, 
                               bigger_is_better = TRUE, log_scale = TRUE, main_title = "lpost predictive var")




plot(plt_mean)
plot(plt_var)
plot(IVAR_lpost_grid_prior_wt_plot)
plot(IVAR_post_grid_prior_wt_plot)
plot(IVAR_post_grid_prior_wt_plot2)


```


```{r}
# TODO:
#    - LOOK AT EFFECT OF CONDITIONING ON INDIVUDAL POINTS TO BETTER UNDERSTAND INTEGRATED VARIANCE. 
#    - 1D PLOTS OF INTEGRATED VARIANCE
#    - PLOTS INVESTIGATING THE EFFECT OF TEH DOMINANT TERMS IN IVAR-POST AND IVAR-LPOST

# ALL THESE PLOTS SHOULD BE PUT IN THE IVAR EXPLORATION DOCUMENT. START WITH 1D CASE. 
```






```{r, include = FALSE}
# Sub-sample approximate posterior samples to use as weight points in acquisitions. 
N_support_points <- 1000

support_points_list <- support::sp(n = N_support_points, 
                                   p = length(computer_model_data$theta_true), 
                                   dist.samp = samp_round0_info$inputs)
support_points <- support_points_list$sp
colnames(support_points) <- colnames(lpost_emulator$inputs_lpost$inputs)
support_point_info <- list(inputs = support_points, 
                           inputs_scaled = scale_input_data(support_points, input_bounds = init_design_info$input_bounds))

support_point_plot <- get_2d_heatmap_plot(X = samp_round0_info$inputs, y = lpost_emulator_pred_round0$mean, 
                                          param_names = computer_model_data$pars_cal_names, 
                                          raster = FALSE, 
                                          samples_points = support_points, 
                                          bigger_is_better = TRUE, 
                                          main_title = "Support Points")

plot(support_point_plot)
```
```{r}
plot(support_point_plot)
```

```{r}
# Approx Posterior-Weighted 
# NOTE: plotting negative of IVAR vals to avoid negatives to produce more intuitive plots. 
# TODO: should probably also keep consistent color scheme (i.e. yellow = bigger)
# TODO: IVAR-lpost plots seem to become much more discontinuous/jumpy when the number of design points increases. 
#       Investigate why this may be; assuming it is something to do with numerical instability. 

# Evaluate Acquisitions. 
IVAR_lpost_grid_post_wt <- acquisition_EIVAR_lpost(theta_vals = prior_grid_info$inputs_scaled, 
                                                   lpost_emulator = lpost_emulator, 
                                                   theta_grid_integrate = support_point_info$inputs_scaled, 
                                                   verbose = FALSE, include_nugget = TRUE)

IVAR_post_grid_post_wt <- acquisition_IVAR_post(theta_vals = prior_grid_info$inputs_scaled, 
                                                lpost_emulator = lpost_emulator, 
                                                theta_grid_integrate = support_point_info$inputs_scaled, 
                                                verbose = FALSE, include_nugget = TRUE)

# Optimizers of acquisitions. 
IVAR_lpost_grid_post_wt_best_idx <- which.max(IVAR_lpost_grid_post_wt)
IVAR_post_grid_post_wt_best_idx <- which.max(IVAR_post_grid_post_wt)
  
# Generate Plots. 
IVAR_lpost_grid_post_wt_plot <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                                    y = -IVAR_lpost_grid_post_wt, param_names = computer_model_data$pars_cal_names, 
                                                    samples_kde = samp_exact_theta, raster = TRUE, 
                                                    samples_points = init_design_info$inputs, 
                                                    bigger_is_better = FALSE, 
                                                    point_coords = prior_grid_info$inputs[IVAR_lpost_grid_post_wt_best_idx,],
                                                    main_title = "IVAR-lpost, Approx Posterior Weights", point_coords_col = "black")
IVAR_post_grid_post_wt_plot <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                                   y = -IVAR_post_grid_post_wt, param_names = computer_model_data$pars_cal_names, 
                                                   samples_kde = samp_exact_theta, raster = TRUE, 
                                                   samples_points = init_design_info$inputs, 
                                                   bigger_is_better = FALSE, 
                                                   point_coords = prior_grid_info$inputs[IVAR_post_grid_post_wt_best_idx,],
                                                   main_title = "IVAR-post, Approx Posterior Weights", point_coords_col = "black")

plot(IVAR_lpost_grid_post_wt_plot)
plot(IVAR_post_grid_post_wt_plot)

```

```{r}
N_acq <- 10

lpost_emulator_lpost_temp <- lpost_emulator
plt_list <- vector(mode = "list", length = N_acq)

for(i in seq_len(N_acq)) {
  
  # Evaluate Acquisition. 
  acq_values <- acquisition_EIVAR_lpost(theta_vals = prior_grid_info$inputs_scaled, 
                                        lpost_emulator = lpost_emulator_lpost_temp, 
                                        theta_grid_integrate = support_point_info$inputs_scaled, 
                                        verbose = FALSE, include_nugget = TRUE)
  # Optimizer of acquisition. 
  best_idx <- which.max(acq_values)
  
  # Generate plot. 
  plt_list[[i]] <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                       y = -acq_values, param_names = computer_model_data$pars_cal_names, 
                                       samples_kde = samp_exact_theta, raster = TRUE, 
                                       samples_points = lpost_emulator_lpost_temp$inputs_lpost$inputs, 
                                       bigger_is_better = FALSE, 
                                       point_coords = prior_grid_info$inputs[best_idx,],
                                       main_title = paste0("IVAR-lpost, Approx Posterior Weights, Iteration ", i), point_coords_col = "black")
  
  # Update emulator using true observation (but keep hyperparameters fixed). 
  lpost_obs_new <- prior_grid_info$lpost[best_idx]
  lpost_emulator_lpost_temp <- update_lpost_emulator(lpost_emulator = lpost_emulator_lpost_temp, 
                                                     inputs_new_scaled = prior_grid_info$inputs_scaled[best_idx,, drop=FALSE], 
                                                     inputs_new_unscaled = prior_grid_info$inputs[best_idx,, drop=FALSE], 
                                                     outputs_lpost_new = lpost_obs_new)
  
}

```


```{r}
# TODO: should do these plots with added approx round0 contours, as well as using predictive variance or mean as heatmap. 

for(i in seq_len(N_acq)) plot(plt_list[[i]])

```

```{r}
# Plot numbered acquisitions. 
new_design_sel <- seq(design_settings$N_design+1, nrow(lpost_emulator_lpost_temp$inputs_lpost$inputs))
  
lpost_numbered_plot <- get_2d_Bayes_opt_heatmap_plot(theta_vals = prior_grid_info$inputs, 
                                                     lpost_vals = prior_grid_info$lpost,
                                                     param_names = computer_model_data$pars_cal_names,
                                                     samples_kde = samp_exact_theta, 
                                                     init_design_points = lpost_emulator$inputs_lpost$inputs, 
                                                     sequential_design_points =lpost_emulator_lpost_temp$inputs_lpost$inputs[new_design_sel,,drop=FALSE],
                                                     raster = TRUE, 
                                                     main_title = "IVAR-lpost Acquisitions and True Post", bigger_is_better = TRUE)

# Heatmap from approx distribution but contours from true distribution. 
lpost_numbered_plot_approx_scatter <- get_2d_Bayes_opt_heatmap_plot(theta_vals = samp_round0_info$inputs, 
                                                                   lpost_vals = samp_round0_info$outputs, # samp_round0_info$outputs,
                                                                   param_names = computer_model_data$pars_cal_names,
                                                                   samples_kde = samp_exact_theta, 
                                                                   init_design_points = lpost_emulator$inputs_lpost$inputs, 
                                                                   sequential_design_points=lpost_emulator_lpost_temp$inputs_lpost$inputs[new_design_sel,,drop=FALSE],
                                                                   raster = FALSE, 
                                                                   main_title = "IVAR-lpost Acquisitions and Approx Round0 Samp", 
                                                                   legend_label = "Log Post",
                                                                   bigger_is_better = TRUE)
                                                      
plot(lpost_numbered_plot)

# Targets points towards the center of the approx distribution and then works its way to the boundaries as the center is covered. 
# This makes sense given the global scope of the integrated variance criterion. 
plot(lpost_numbered_plot_approx_scatter) 


```


```{r}

lpost_emulator_post_temp <- lpost_emulator
post_plt_list <- vector(mode = "list", length = N_acq)

for(i in seq_len(N_acq)) {
  
  # Evaluate Acquisition. 
  acq_values <- acquisition_IVAR_post(theta_vals = prior_grid_info$inputs_scaled, 
                                      lpost_emulator = lpost_emulator_post_temp, 
                                      theta_grid_integrate = support_point_info$inputs_scaled, 
                                      verbose = FALSE, include_nugget = TRUE)
  # Optimizer of acquisition. 
  best_idx <- which.max(acq_values)
  
  # Generate plot. 
  post_plt_list[[i]] <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                            y = -acq_values, param_names = computer_model_data$pars_cal_names, 
                                            samples_kde = samp_exact_theta, raster = TRUE, 
                                            samples_points = lpost_emulator_post_temp$inputs_lpost$inputs, 
                                            bigger_is_better = FALSE, 
                                            point_coords = prior_grid_info$inputs[best_idx,],
                                            main_title = paste0("IVAR-post, Approx Posterior Weights, Iteration ", i), point_coords_col = "black")
  
  # Update emulator using true observation (but keep hyperparameters fixed). 
  lpost_obs_new <- prior_grid_info$lpost[best_idx]
  lpost_emulator_post_temp <- update_lpost_emulator(lpost_emulator = lpost_emulator_post_temp, 
                                                    inputs_new_scaled = prior_grid_info$inputs_scaled[best_idx,, drop=FALSE], 
                                                    inputs_new_unscaled = prior_grid_info$inputs[best_idx,, drop=FALSE], 
                                                    outputs_lpost_new = lpost_obs_new)
  
}

```


```{r}

for(i in seq_len(N_acq)) plot(post_plt_list[[i]])

```

```{r}
# Plot numbered acquisitions. 

new_design_sel <- seq(design_settings$N_design+1, nrow(lpost_emulator_post_temp$inputs_lpost$inputs))
  
post_numbered_plot <- get_2d_Bayes_opt_heatmap_plot(theta_vals = prior_grid_info$inputs, 
                                                    lpost_vals = prior_grid_info$lpost,
                                                    param_names = computer_model_data$pars_cal_names,
                                                    samples_kde = samp_exact_theta, 
                                                    init_design_points = lpost_emulator$inputs_lpost$inputs, 
                                                    sequential_design_points=lpost_emulator_post_temp$inputs_lpost$inputs[new_design_sel,,drop=FALSE],
                                                    raster = TRUE, 
                                                    main_title = "IVAR-post Acquisitions; true post contours", bigger_is_better = TRUE)

# Heatmap from true distribution, but contours from approx distribution. 
# TODO: maybe want to overlay both true and approx contours. 
# TODO: also would be interesting to run approx MCMC with fixed sig2_eps estimate to see how acquisitions (with this fixed estimate)
#       align with approx posterior under fixed estimate. 
post_numbered_plot_approx <- get_2d_Bayes_opt_heatmap_plot(theta_vals = prior_grid_info$inputs, 
                                                           lpost_vals = prior_grid_info$lpost,
                                                           param_names = computer_model_data$pars_cal_names,
                                                           samples_kde = samp_round0_info$inputs, 
                                                           init_design_points = lpost_emulator$inputs_lpost$inputs, 
                                                           sequential_design_points=lpost_emulator_post_temp$inputs_lpost$inputs[new_design_sel,,drop=FALSE],
                                                           raster = TRUE, 
                                                           main_title = "IVAR-post Acquisitions; approx post contours", 
                                                           bigger_is_better = TRUE)

# Heatmap from approx distribution but contours from true distribution. 
# TODO: change the argument `lpost_vals` to be more general (e.g. passing in predictive variance here).
post_numbered_plot_approx_scatter <- get_2d_Bayes_opt_heatmap_plot(theta_vals = samp_round0_info$inputs, 
                                                                   lpost_vals = lpost_emulator_pred_round0$var, # samp_round0_info$outputs,
                                                                   param_names = computer_model_data$pars_cal_names,
                                                                   samples_kde = samp_exact_theta, 
                                                                   init_design_points = lpost_emulator$inputs_lpost$inputs, 
                                                                   sequential_design_points=lpost_emulator_post_temp$inputs_lpost$inputs[new_design_sel,,drop=FALSE],
                                                                   raster = FALSE, 
                                                                   main_title = "IVAR-post Acquisitions", 
                                                                   legend_label = "lpost pred var",
                                                                   bigger_is_better = TRUE)

                                                      
plot(post_numbered_plot)
plot(post_numbered_plot_approx)

# Seems like the complete opposite of IVAR-lpost. Acting almost like MaxVar, targeting regions on the 
# edges of the approx posterior and then finally later on working its way to the center. My guess is 
# that exponentiating the variance causes it to completely dominate the mean. 
plot(post_numbered_plot_approx_scatter) 

```

## Re-fit kernel hyperparameters. 
```{r, include = FALSE}
# TODO: should have this functionality built into lpost_emulator object. Also should save the SSR vals as points are acquired to avoid 
#       having to re-calculate here. 

# # IVAR-lpost. 
# inputs_IVAR_lpost_round1 <- lpost_emulator_lpost_temp$inputs_lpost$inputs[new_design_sel,,drop=FALSE]
# SSR_lpost_round1 <- get_computer_model_SSR(computer_model_data, theta_vals = inputs_IVAR_lpost_round1, na.rm = TRUE)
# gp_fits_IVAR_lpost_round1 <- update_independent_GPs(gp_fits = lpost_emulator_lpost_temp$emulator_info_list$gp_fits, 
#                                                     gp_lib = lpost_emulator_lpost_temp$emulator_info_list$settings$gp_lib, 
#                                                     X_new = inputs_IVAR_lpost_round1, Y_new = SSR_lpost_round1, 
#                                                     update_hyperparameters = TRUE, 
#                                                     input_bounds = lpost_emulator_lpost_temp$design_info_list$input_bounds, 
#                                                     output_stats = lpost_emulator_lpost_temp$design_info_list$output_stats)
# lpost_emulator_lpost_temp$emulator_info_list$gp_fits <- gp_fits_IVAR_lpost_round1 # Should also update design_info_list.
# lpost_emulator_lpost_temp$design_info_list$round0_estimates$best_input <- colMeans(samp_round0_info$inputs)
# lpost_emulator_lpost_temp$design_info_list$round0_estimates$best_sig2_eps <- colMeans(samp_round0_sig_eps)
# 
# # IVAR-post.
# inputs_IVAR_post_round1 <- lpost_emulator_post_temp$inputs_lpost$inputs[new_design_sel,,drop=FALSE]
# SSR_post_round1 <- get_computer_model_SSR(computer_model_data, theta_vals = inputs_IVAR_post_round1, na.rm = TRUE)
# gp_fits_IVAR_post_round1 <- update_independent_GPs(gp_fits = lpost_emulator_post_temp$emulator_info_list$gp_fits, 
#                                                    gp_lib = lpost_emulator_post_temp$emulator_info_list$settings$gp_lib, 
#                                                    X_new = inputs_IVAR_post_round1, Y_new = SSR_post_round1, 
#                                                    update_hyperparameters = TRUE, 
#                                                    input_bounds = lpost_emulator_post_temp$design_info_list$input_bounds, 
#                                                    output_stats = lpost_emulator_post_temp$design_info_list$output_stats)
# lpost_emulator_lpost_temp$emulator_info_list$gp_fits <- gp_fits_IVAR_post_round1
# lpost_emulator_post_temp$design_info_list$round0_estimates$best_input <- colMeans(samp_round0_info$inputs)
# lpost_emulator_post_temp$design_info_list$round0_estimates$best_sig2_eps <- colMeans(samp_round0_sig_eps)



```


# Round 1 approximate sampling. 

```{r, include = FALSE}
#
# Round 1 approximate posterior sampling: IVAR-lpost
#

# mcmc_approx_IVAR_lpost_round1 <- mcmc_calibrate_ind_GP(computer_model_data = computer_model_data, 
#                                                        theta_prior_params = theta_prior_params, 
#                                                        emulator_info = lpost_emulator_lpost_temp$emulator_info_list,
#                                                        theta_init = lpost_emulator_lpost_temp$design_info_list$round0_estimates$best_input, 
#                                                        sig_eps_init = lpost_emulator_lpost_temp$design_info_list$round0_estimates$best_sig2_eps, 
#                                                        learn_sig_eps = TRUE, 
#                                                        sig_eps_prior_params = sig_eps_prior_params, 
#                                                        N_mcmc = N_mcmc_approx)
```

```{r, include = FALSE}
# # Combine with existing data.table of MCMC output. 
# mcmc_samp_dt <- rbindlist(list(mcmc_samp_dt, format_mcmc_output(samp_list = mcmc_approx_IVAR_lpost_round1[c("theta", "sig_eps")], test_label = "round1_IVAR_lpost")), 
#                           use.names = TRUE)
```

### Round 1 MCMC sampling diagnostics. 
```{r, include = FALSE}

# burn_ins <- c(burn_ins, round1_IVAR_post = 10000)
# 
# mcmc_round1_IVAR_lpost_trace_plts <- get_trace_plots(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "round1_IVAR_lpost", param_types = "theta")
# mcmc_round1_IVAR_lpost_trace_plts_sig_eps <- get_trace_plots(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "round1_IVAR_lpost", param_types = "sig_eps")
# 
# grid.arrange(arrangeGrob(grobs = mcmc_round1_IVAR_lpost_trace_plts, nrow = 1))
# grid.arrange(arrangeGrob(grobs = mcmc_round1_IVAR_lpost_trace_plts_sig_eps, nrow = 1))
```

```{r, include = FALSE}
# Store round1 IVAR-lpost MCMC output. 

#
# Store round 0 MCMC approximate posterior samples. These are used as candidate/integration points for sequential design, 
# as well as for plotting purposes. 
#

# samp_round1_IVAR_lpost_theta <- select_mcmc_samp(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "round1_IVAR_lpost", param_types = "theta")[, .(param_name, sample)]
# samp_round1_IVAR_lpost_theta <- as.matrix(unstack(samp_round1_IVAR_lpost_theta, sample ~ param_name))[, computer_model_data$pars_cal_names]
# 
# samp_round1_IVAR_lpost_sig_eps <- select_mcmc_samp(mcmc_samp_dt, burn_in_start = burn_ins, 
#                                                    test_labels = "round1_IVAR_lpost", param_types = "sig_eps")[, .(param_name, sample)]
# samp_round1_IVAR_lpost_sig_eps <- as.matrix(unstack(samp_round1_IVAR_lpost_sig_eps, sample ~ param_name))[, computer_model_data$output_vars]
```









