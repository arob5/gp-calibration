---
title: "IVAR Exploration"
author: "Andrew Roberts"
date: '2023-08-25'
output: html_document
---

```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(lhs)
library(hetGP)
library(mlegp)
library(ggplot2)
library(viridis)
library(parallel)
library(gridExtra)
library(data.table)
library(BayesianTools)

source("numerical_experiment_functions.r")
source("mcmc_calibration_functions.r")
source("gp_emulator_functions.r")
source("sequential_design_optimization.r")
```


# Computer Model and Data 

```{r, include = FALSE}
# Synthetic data generation
computer_model_data <- generate_vsem_test_case(4)
```

```{r, echo = FALSE}
print(computer_model_data$ref_pars[computer_model_data$pars_cal_sel,])
```

```{r echo = FALSE}
for(output_var in computer_model_data$output_vars) {
 plotTimeSeries(observed = computer_model_data$data_obs[, output_var],
                predicted = computer_model_data$data_ref[, output_var], main = output_var) 
}
```

# Priors 

## Calibration Parameters 
```{r, echo = FALSE} 
# Priors 
theta_prior_params <- computer_model_data$ref_pars[computer_model_data$pars_cal_sel,]
theta_prior_params[, "dist"] <- c("Uniform", "Uniform")
theta_prior_params[,"param1"] <- c(1.3, 0.4) # theta_prior_params[,"lower"]
theta_prior_params[,"param2"] <- c(1.7, 0.6)  # theta_prior_params[,"upper"]
theta_prior_params <- theta_prior_params[, c("dist", "param1", "param2")]

print("Calibration parameter prior:")
print(theta_prior_params)
```


## Likelihood Parameters 
```{r, echo = FALSE}
sig2_prior_info <- get_IG_priors_numerical_test(sig2_true = diag(computer_model_data$Sig_eps), 
                                                bias_frac = c(0.1, -0.15), bins = 50,
                                                coef_var = c(0.3, 0.5), return_prior_plots = TRUE, 
                                                output_variables = computer_model_data$output_vars)
sig_eps_prior_params <- sig2_prior_info$prior
plts <- sig2_prior_info$plots

print("Priors on variance parameters:")
grid.arrange(arrangeGrob(grobs = plts, nrow = 1))
```

# Exact MCMC Samples.

## Exact MCMC. 
```{r, echo = FALSE}
N_mcmc_exact <- 50000

time_start <- proc.time()
mcmc_exact_list <- mcmc_calibrate_product_lik(computer_model_data = computer_model_data, 
                                              theta_prior_params = theta_prior_params, 
                                              learn_sig_eps = TRUE,
                                              sig_eps_prior_params = sig_eps_prior_params,
                                              N_mcmc = N_mcmc_exact)
mcmc_exact_runtime <- (proc.time() - time_start)[["elapsed"]]
print(paste0("Exact MCMC runtime: ", mcmc_exact_runtime, " seconds."))

# Format MCMC samples. 
mcmc_samp_dt <- format_mcmc_output(samp_list = mcmc_exact_list[c("theta", "sig_eps")], test_label = "exact")

```

```{r, echo = FALSE}
burn_ins <- c(exact = 10000)

mcmc_exact_trace_plts <- get_trace_plots(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "exact", param_types = "theta")
grid.arrange(arrangeGrob(grobs = mcmc_exact_trace_plts, nrow = 1))
```

```{r, echo = FALSE}
mcmc_exact_trace_plts_sig_eps <- get_trace_plots(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "exact", param_types = "sig_eps")
grid.arrange(arrangeGrob(grobs = mcmc_exact_trace_plts_sig_eps, nrow = 1))
```

```{r, echo = FALSE}
# Store matrix of calibration parameter samples from exact MCMC for plotting purposes. 
samp_exact_theta <- select_mcmc_samp(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "exact", param_types = "theta")[, .(param_name, sample)]
samp_exact_theta <- as.matrix(unstack(samp_exact_theta, sample ~ param_name))[, computer_model_data$pars_cal_names]
```


# Setup for Design Initialization. 

```{r, echo = FALSE}
# Emulator settings
emulator_settings <- data.frame(gp_lib = c("hetGP"), 
                                kernel = "Gaussian", 
                                transformation_method = c("truncated"),
                                emulator_target = "SSR",
                                scale_X = TRUE, 
                                normalize_y = TRUE)

print("Emulator Settings:")
print(emulator_settings)
```

```{r, echo = FALSE}

# Design settings.
design_settings <- data.frame(N_design = 15, design_method = "LHS")
design_seed <- 5
set.seed(design_seed)

# Input bounds that will be used to scale all designs. 
input_bounds <- t(as.matrix(theta_prior_params[, c("param1", "param2")]))
rownames(input_bounds) <- c("min", "max")

print("Design Settings:")
print(design_settings)
```

```{r, include = FALSE}
# Prior grid over which acquisitions will be evaluated. Also will be used for plotting. 

prior_grid_info <- get_input_output_design(N_points = 51^2,
                                           design_method = "grid", 
                                           scale_inputs = TRUE,
                                           param_ranges = input_bounds,
                                           computer_model_data = computer_model_data, 
                                           theta_prior_params = theta_prior_params)

lpost_true_grid <- calc_lpost_theta_product_lik(computer_model_data = computer_model_data, 
                                                theta_vals = prior_grid_info$inputs, 
                                                vars_obs = diag(computer_model_data$Sig_eps), 
                                                SSR = prior_grid_info$outputs,
                                                na.rm = TRUE, theta_prior_params = theta_prior_params, 
                                                return_list = FALSE)

# Index selectors for candidate and integration points. 
theta_grid_candidate_sel <- seq_len(nrow(prior_grid_info$inputs_scaled))
theta_grid_integrate_sel <- seq_len(nrow(prior_grid_info$inputs_scaled))

```


```{r, echo = FALSE}

# True posterior heatmap plot. 
true_post_plot <- get_2d_response_surface_plot(computer_model_data = computer_model_data, 
                                               theta_vals = prior_grid_info$inputs, 
                                               param_names = computer_model_data$pars_cal_names, 
                                               response_surface = "posterior", 
                                               output_variables = computer_model_data$output_vars, 
                                               raster = TRUE, point_coords = computer_model_data$theta_true, 
                                               samples_kde = samp_exact_theta, lpost_vals = lpost_true_grid)

plot(true_post_plot)
```


# IVAR acquisition evaluations on different initial designs.  

```{r, include = FALSE}

N_design_tests <- 1
design_list <- vector(mode = "list", length = N_design_tests)
lpost_emulator_list <- vector(mode = "list", length = N_design_tests)
pred_list <- vector(mode = "list", length = N_design_tests)
plt_list <- vector(mode = "list", length = N_design_tests)

for(design_itr in seq_len(N_design_tests)) {

  # Generate initial design.
  init_design <- get_input_output_design(N_points = design_settings$N_design, 
                                         computer_model_data = computer_model_data, 
                                         theta_prior_params = theta_prior_params, 
                                         param_ranges = input_bounds,
                                         scale_inputs = TRUE, 
                                         normalize_response = TRUE, 
                                         design_method = design_settings$design_method, 
                                         na.rm = TRUE)
  init_design$input_bounds <- input_bounds
  init_estimates <- get_init_param_estimates(init_design, computer_model_data, sig_eps_prior_params, verbose = FALSE)
  init_design$init_estimates <- init_estimates
  design_list[[design_itr]] <- init_design
  
  # Fit GP on initial design. 
  gp_fits <- fit_independent_GPs(X_train = init_design$inputs_scaled, Y_train = init_design$outputs_normalized, 
                                 gp_lib = emulator_settings$gp_lib, gp_kernel = emulator_settings$kernel)$fits
  emulator_info_list <- list(gp_fits = gp_fits, input_bounds = input_bounds, 
                             output_stats = init_design$output_stats, settings = emulator_settings)
  lpost_emulator <- get_lpost_emulator_obj(emulator_info_list = emulator_info_list, design_info_list = init_design, 
                                           computer_model_data = computer_model_data, sig2_eps = init_design$init_estimates$best_sig2_eps, 
                                           theta_prior_params = theta_prior_params)

  # Generate lpost predictive plots. 
  lpost_emulator_pred<- predict_lpost_emulator(lpost_emulator = lpost_emulator, 
                                               inputs_new_scaled = prior_grid_info$inputs_scaled, 
                                               inputs_new_unscaled = prior_grid_info$inputs, include_nugget = TRUE)
  pred_list[[design_itr]] <- list()
  pred_list[[design_itr]]$lpost_emulator_pred <- lpost_emulator_pred
  
  # Produce IVAR-post and IVAR-lpost evaluations. 
  IVAR_lpost_vals <- acquisition_EIVAR_lpost(theta_vals = prior_grid_info$inputs_scaled[theta_grid_candidate_sel,], 
                                             lpost_emulator = lpost_emulator, 
                                             theta_grid_integrate = prior_grid_info$inputs_scaled[theta_grid_integrate_sel,], 
                                             verbose = FALSE, include_nugget = TRUE)
  IVAR_post_vals <- acquisition_IVAR_post(theta_vals = prior_grid_info$inputs_scaled[theta_grid_candidate_sel,], 
                                          lpost_emulator = lpost_emulator, 
                                          theta_grid_integrate = prior_grid_info$inputs_scaled[theta_grid_integrate_sel,], 
                                          verbose = FALSE, include_nugget = TRUE)
  pred_list[[design_itr]]$IVAR_lpost <- IVAR_lpost_vals
  pred_list[[design_itr]]$IVAR_post <- IVAR_post_vals
  
  
  # Produce plots. 
  plt_list[[design_itr]] <- list(scatter = list(), heatmap = list(), lpost_pred = list())
  plt_list[[design_itr]]$lpost_pred$mean <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                                                y = lpost_emulator_pred$mean, param_names = computer_model_data$pars_cal_names, 
                                                                samples_kde = samp_exact_theta, raster = TRUE, 
                                                                samples_points = init_design$inputs, 
                                                                point_coords = computer_model_data$theta_true, bigger_is_better = TRUE, 
                                                                main_title = "lpost predictive mean")
  plt_list[[design_itr]]$lpost_pred$var <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                                               y = lpost_emulator_pred$var, param_names = computer_model_data$pars_cal_names, 
                                                               samples_kde = samp_exact_theta, raster = TRUE, 
                                                               samples_points = init_design$inputs, log_scale = TRUE, 
                                                               point_coords = computer_model_data$theta_true, bigger_is_better = TRUE, 
                                                               main_title = "lpost predictive var")

  plt_list[[design_itr]]$heatmap$IVAR_lpost <- get_2d_heatmap_plot(X = prior_grid_info$inputs[theta_grid_candidate_sel,], 
                                                                   y = IVAR_lpost_vals, param_names = computer_model_data$pars_cal_names, 
                                                                   samples_kde = samp_exact_theta, raster = TRUE, 
                                                                   samples_points = init_design$inputs, 
                                                                   point_coords = computer_model_data$theta_true, bigger_is_better = TRUE, 
                                                                   main_title = "IVAR-lpost")
  plt_list[[design_itr]]$heatmap$IVAR_post <- get_2d_heatmap_plot(X = prior_grid_info$inputs[theta_grid_candidate_sel,], 
                                                                  y = IVAR_post_vals, param_names = computer_model_data$pars_cal_names, 
                                                                  samples_kde = samp_exact_theta, raster = TRUE, 
                                                                  samples_points = init_design$inputs, 
                                                                  point_coords = computer_model_data$theta_true, bigger_is_better = TRUE, 
                                                                  main_title = "log IVAR-post")
  plt_list[[design_itr]]$scatter$IVAR_lpost$mean <- plot(x = lpost_emulator_pred$mean[theta_grid_candidate_sel], 
                                                         y = IVAR_lpost_vals, 
                                                         xlab = "lpost pred mean", ylab = "IVAR-lpost", main = "Predictive Mean vs. Acquisition")
  plt_list[[design_itr]]$scatter$IVAR_post$mean <- plot(x = lpost_emulator_pred$mean[theta_grid_candidate_sel], 
                                                        y = IVAR_post_vals, 
                                                        xlab = "lpost pred mean", ylab = "log IVAR-post", main = "Predictive Mean vs. Acquisition")
  plt_list[[design_itr]]$scatter$IVAR_lpost$var <- plot(x = lpost_emulator_pred$var[theta_grid_candidate_sel], 
                                                        y = IVAR_lpost_vals, 
                                                        xlab = "lpost pred var", ylab = "IVAR-lpost", main = "Predictive Var vs. Acquisition")
  plt_list[[design_itr]]$scatter$IVAR_post$var <- plot(x = lpost_emulator_pred$var[theta_grid_candidate_sel], 
                                                       y = IVAR_post_vals, 
                                                       xlab = "lpost pred var", ylab = "log IVAR-post", main = "Predictive Var vs. Acquisition")
  
  
}

```


```{r}
# Compare true log posterior density to lpost emulator. 
plot(true_post_plot)
plot(plt_list[[1]]$lpost_pred$mean)
plot(plt_list[[1]]$lpost_pred$var)
```

```{r}
# Compare true log posterior density to log of post emulator moments. 

mu <- pred_list[[1]]$lpost_emulator_pred$mean
sig2 <- pred_list[[1]]$lpost_emulator_pred$var

log_post_mean <- mu + 0.5 * sig2

idx_approx_sel <- (sig2 >= 100)
log_exp_term <- vector(mode = "numeric", length = length(sig2))
log_exp_term[!idx_approx_sel] <- log(exp(sig2[!idx_approx_sel]) - 1)
log_exp_term[idx_approx_sel] <- sig2[idx_approx_sel] # Apply approximation. 

log_post_var <- 2*mu + sig2 + log_exp_term 


post_mean_plot <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                      y = log_post_mean - min(log_post_mean) + 1 , param_names = computer_model_data$pars_cal_names, 
                                      samples_kde = samp_exact_theta, raster = TRUE, 
                                      samples_points = init_design$inputs, log_scale = TRUE, 
                                      point_coords = computer_model_data$theta_true, bigger_is_better = TRUE, 
                                      main_title = "log of post predictive mean")
post_var_plot <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                     y = log_post_var - min(log_post_var) + 1, param_names = computer_model_data$pars_cal_names, 
                                     samples_kde = samp_exact_theta, raster = TRUE, 
                                     samples_points = init_design$inputs, log_scale = TRUE,
                                     point_coords = computer_model_data$theta_true, bigger_is_better = TRUE, 
                                     main_title = "log of post predictive var")

plot(true_post_plot)
plot(post_mean_plot)
plot(post_var_plot)
```


```{r}
plot(plt_list[[design_itr]]$heatmap$IVAR_lpost)
plot(plt_list[[design_itr]]$heatmap$IVAR_post)
```






```{r}
# TODO: need to compare to predictive mean and variance of lpost_emulator. 
# TODO: also, compare predictive mean and (log) variance of post_emulator to that of lpost_emulator. 
# TODO: scatterplots comparing the acquisitions to the lpost emulator predictive mean and variance. 
plot(plt_list[[1]]$IVAR_lpost)
plot(plt_list[[1]]$IVAR_post)
```










