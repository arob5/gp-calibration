---
title: "IVAR Exploration"
author: "Andrew Roberts"
date: '2023-08-25'
output: html_document
---

```{r, echo = TRUE, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(lhs)
library(hetGP)
library(mlegp)
library(ggplot2)
library(viridis)
library(parallel)
library(gridExtra)
library(data.table)
library(BayesianTools)

source("numerical_experiment_functions.r")
source("mcmc_calibration_functions.r")
source("gp_emulator_functions.r")
source("sequential_design_optimization.r")
```

# One-Dimensional Linear Gaussian Example 

We begin we the simplest possible example, the one-dimensional linear Gaussian model 
$$
\begin{align*}
\mathbf{y} &= \mathbf{g}u + \epsilon \\
\epsilon &\sim \mathcal{N}(0, \sigma_\epsilon^2) \\
u &\sim \mathcal{N}(\mu_0, \sigma^2_0),
\end{align*}
$$
where $\mathbf{g}, \mathbf{y} \in \mathbb{R}^T$ and the noise variance $\sigma_\epsilon^2$ is assumed to be known. This results in an unnormalized log posterior density 
$$
\ell^\pi(u) \propto -\frac{1}{2} \log(2\pi\sigma_{\epsilon}^2) - \frac{\Phi(u)}{2\sigma^2_\epsilon} - \frac{1}{2\sigma^2_0}(u - \mu_0)^2,
$$
where 
$$
\Phi(u) := ||\mathbf{y} - \mathbf{g}u||_2^2
$$
is the data-misfit. 



```{r}
# Linear Gaussian Model Setup. 
linear_Gaussian_seed <- 72
N_obs <- 100
freq <- 1
g <- matrix(sin(2*pi*freq*seq(1, N_obs)/N_obs), ncol = 1)
sig2_eps <- 1
sig2_0 <- matrix(1)
mu0 <- 0

linear_Gaussian_info <- generate_linear_Gaussian_test_data(linear_Gaussian_seed, N_obs = N_obs, D = 1, Sig_theta = sig2_0, G = g, sig2_eps = sig2_eps)
computer_model_data <- linear_Gaussian_info$computer_model_data
theta_prior_params <- linear_Gaussian_info$theta_prior_params

plot(1:N_obs, computer_model_data$data_obs, main = "Ground Truth and Observed Data", xlab = "t")
lines(1:N_obs, computer_model_data$data_ref, col = "red")
```


```{r}
# Initial design and grid of points for plotting purposes. 

# Initial design (round 0). 
design_settings <- data.frame(N_design = 3, design_method = "LHS", design_seed = 5)
init_design_info <- get_input_output_design(N_points = design_settings$N_design,
                                            design_method = design_settings$design_method, 
                                            scale_inputs = TRUE,
                                            computer_model_data = computer_model_data, 
                                            theta_prior_params = theta_prior_params)
init_design_info$lpost <- calc_lpost_theta_product_lik(computer_model_data = computer_model_data, 
                                                       theta_vals = init_design_info$inputs, 
                                                       vars_obs = diag(computer_model_data$Sig_eps), 
                                                       SSR = init_design_info$outputs,
                                                       na.rm = TRUE, theta_prior_params = theta_prior_params, 
                                                       return_list = FALSE)

# Grid of points spread across prior (for plotting).  
prior_grid_info <- get_input_output_design(N_points = 1000,
                                           design_method = "grid", 
                                           scale_inputs = TRUE,
                                           param_ranges = init_design_info$input_bounds,
                                           computer_model_data = computer_model_data, 
                                           theta_prior_params = theta_prior_params, 
                                           design_seed = design_settings$design_seed)
prior_grid_info$lpost <- calc_lpost_theta_product_lik(computer_model_data = computer_model_data, 
                                                      theta_vals = prior_grid_info$inputs, 
                                                      vars_obs = diag(computer_model_data$Sig_eps), 
                                                      SSR = prior_grid_info$outputs,
                                                      na.rm = TRUE, theta_prior_params = theta_prior_params, 
                                                      return_list = FALSE)


# lpost
plot(prior_grid_info$inputs, prior_grid_info$lpost, col = "red", type = "l", 
     main = "Prior Design and True lpost values", xlab = "u", ylab = "Unnormalized log posterior")
points(init_design_info$inputs, init_design_info$lpost, col = "black")

# SSR 
plot(prior_grid_info$inputs, prior_grid_info$outputs, col = "red", type = "l", 
     main = "Prior Design and True Data Misfit values", xlab = "u", ylab = "Data Misfit")
points(init_design_info$inputs, init_design_info$outputs, col = "black")

```

## GP Fit on Initial Design 

```{r}
# Emulator settings
emulator_settings <- data.frame(gp_lib = c("hetGP"), 
                                kernel = "Gaussian", 
                                transformation_method = c("truncated"),
                                emulator_target = "SSR",
                                scale_X = TRUE, 
                                normalize_y = TRUE)
print(emulator_settings)

# Fit emulators on initial design. 
gp_fits <- fit_independent_GPs(X_train = init_design_info$inputs_scaled, Y_train = init_design_info$outputs_normalized, 
                               gp_lib = emulator_settings$gp_lib, gp_kernel = emulator_settings$kernel)$fits
emulator_info_list <- list(gp_fits = gp_fits, input_bounds = init_design_info$input_bounds, 
                           output_stats = init_design_info$output_stats, settings = emulator_settings)

# Induced log joint density (i.e. log unnormalized posterior density) emulator. 
lpost_emulator <- get_lpost_emulator_obj(emulator_info_list = emulator_info_list, design_info_list = init_design_info, 
                                         computer_model_data = computer_model_data, sig2_eps = sig2_eps, 
                                         theta_prior_params = theta_prior_params, center_output = TRUE, scale_output = TRUE)

# Plot initial emulator fit.
pred_grid_init_design <- predict_lpost_emulator(inputs_new_scaled = prior_grid_info$inputs_scaled, lpost_emulator = lpost_emulator)
upper_CI <- qnorm(.99, pred_grid_init_design$mean, sqrt(pred_grid_init_design$var))
lower_CI <- qnorm(.01, pred_grid_init_design$mean, sqrt(pred_grid_init_design$var)) 

plot(prior_grid_info$inputs, prior_grid_info$lpost, col = "red", type = "l", ylim = c(min(lower_CI), max(upper_CI)),
     main = "lpost Initial GP Fit", xlab = "u", ylab = "Unnormalized log posterior")
points(init_design_info$inputs, init_design_info$lpost, col = "black")
lines(prior_grid_info$inputs, pred_grid_init_design$mean, col = "blue")
lines(prior_grid_info$inputs, upper_CI, col = "gray")
lines(prior_grid_info$inputs, pred_grid_init_design$mean - 2*sqrt(pred_grid_init_design$var), col = "gray")

```

```{r}
# Round 0 approximate posterior sampling. 
N_mcmc_approx <- 50000

mcmc_approx_round0 <- mcmc_calibrate_ind_GP(computer_model_data = computer_model_data, 
                                            theta_prior_params = theta_prior_params, 
                                            emulator_info = lpost_emulator$emulator_info_list,
                                            theta_init = drop(init_design_info$inputs)[which.max(init_design_info$lpost)], 
                                            sig_eps_init = lpost_emulator$sig2_eps, 
                                            learn_sig_eps = FALSE, 
                                            N_mcmc = N_mcmc_approx)

mcmc_samp_dt <- format_mcmc_output(samp_list = mcmc_approx_round0[c("theta")], test_label = "round0")
burn_ins <- c(round0 = 10000)
```

```{r}
# Trace plot. 
round0_trace_plt <- get_trace_plots(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "round0", param_types = "theta")
plot(round0_trace_plt[[1]])
```

```{r}
# Approximate vs. True Samples. 
samp_approx_hist <- as.matrix(select_mcmc_samp(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "round0", param_types = "theta")$sample, ncol=1)
samp_exact <- matrix(rnorm(n = nrow(samp_approx_hist), mean = drop(linear_Gaussian_info$true_posterior$mean), 
                           sd = sqrt(drop(linear_Gaussian_info$true_posterior$Cov))), ncol = 1)

round0_hist_plot <- get_hist_plot(list(samp_exact, samp_approx_hist), bins = 50, xlab = "samples", ylab = "density", 
                                  main_title = "Histogram", data_names = c("exact", "round0")) 

plot(round0_hist_plot)

```
```{r}
# TEST: conditioning GP on a new design point (not re-fitting hyperparameters). 

new_design_point_info <- list(inputs=matrix(-0.5))
new_design_point_info$inputs_scaled <- scale_input_data(new_design_point_info$inputs, input_bounds=init_design_info$input_bounds)
new_design_point_info$outputs <- 


init_design_info <- get_input_output_design(N_points = design_settings$N_design,
                                            design_method = design_settings$design_method, 
                                            scale_inputs = TRUE,
                                            computer_model_data = computer_model_data, 
                                            theta_prior_params = theta_prior_params)
init_design_info$lpost <- calc_lpost_theta_product_lik(computer_model_data = computer_model_data, 
                                                       theta_vals = init_design_info$inputs, 
                                                       vars_obs = diag(computer_model_data$Sig_eps), 
                                                       SSR = init_design_info$outputs,
                                                       na.rm = TRUE, theta_prior_params = theta_prior_params, 
                                                       return_list = FALSE)


```




# Single Point IVAR Acqusitions

```{r}
#
# Uniform Weights. 
#

# Observations: 
#    - Issue: IVAR-post is peaking around the design points. Why would this be? 
#    - One RHS we see IVAR-post drop off much faster than IVAR-lpost, likely because the expected lpost value is 
#      is small on this side of the domain. IVAR-post takes into account predictive lpost mean, unlike IVAR-lpost. 
#      

# Evaluate Acquisitions. 
l_IVAR_uniform_wt <- acquisition_EIVAR_lpost(theta_vals = prior_grid_info$inputs_scaled, lpost_emulator = lpost_emulator_no_scale, 
                                             theta_grid_integrate = prior_grid_info$inputs_scaled, 
                                             include_nugget = TRUE)

IVAR_uniform_wt <- acquisition_IVAR_post(theta_vals = prior_grid_info$inputs_scaled, lpost_emulator = lpost_emulator_no_scale, 
                                         theta_grid_integrate = prior_grid_info$inputs_scaled, 
                                         include_nugget = TRUE)

# Optimizers of acquisitions. 
l_IVAR_uniform_wt_best_idx<- which.max(l_IVAR_uniform_wt)
IVAR_uniform_wt_best_idx <- which.max(IVAR_uniform_wt)
max_var_idx <- which.max(pred_grid_init_design$var)

# Plot. 
plot_max_y <- max(upper_CI)
plot_min_y <- min(lower_CI)
plot_range <- plot_max_y - plot_min_y
l_IVAR_uniform_wt_scaled <- (l_IVAR_uniform_wt - min(l_IVAR_uniform_wt)) / diff(range(l_IVAR_uniform_wt)) * plot_range + plot_min_y
IVAR_uniform_wt_scaled <- (IVAR_uniform_wt - min(IVAR_uniform_wt)) / diff(range(IVAR_uniform_wt)) * plot_range + plot_min_y

plot(prior_grid_info$inputs, prior_grid_info$lpost, col = "red", type = "l", ylim = c(min(lower_CI), max(upper_CI)),
     main = "lpost Initial GP Fit", xlab = "u", ylab = "Unnormalized log posterior")
points(init_design_info$inputs, init_design_info$lpost, col = "black")
lines(prior_grid_info$inputs, pred_grid_init_design$mean, col = "blue")
lines(prior_grid_info$inputs, upper_CI, col = "gray")
lines(prior_grid_info$inputs, pred_grid_init_design$mean - 2*sqrt(pred_grid_init_design$var), col = "gray")
lines(prior_grid_info$inputs, l_IVAR_uniform_wt_scaled, col = "green")
lines(prior_grid_info$inputs, IVAR_uniform_wt_scaled, col = "orange")
points(prior_grid_info$inputs[l_IVAR_uniform_wt_best_idx,], l_IVAR_uniform_wt_scaled[l_IVAR_uniform_wt_best_idx], col = "green", pch = 8)
points(prior_grid_info$inputs[IVAR_uniform_wt_best_idx,], IVAR_uniform_wt_scaled[IVAR_uniform_wt_best_idx], col = "orange", pch = 8)
points(prior_grid_info$inputs[max_var_idx,], upper_CI[max_var_idx], col = "gray", pch = 8)

```


# Effect of Conditioning on Individual Candidate Points. 
```{r}
log_var1 <- get_IVAR_post_vars(theta_candidate = prior_grid_info$inputs_scaled[999,], lpost_emulator_no_scale, theta_grid_integrate = prior_grid_info$inputs_scaled)
log_var2 <- get_IVAR_post_vars(theta_candidate = prior_grid_info$inputs_scaled[1000,], lpost_emulator_no_scale, theta_grid_integrate = prior_grid_info$inputs_scaled)
log_var3 <- get_IVAR_post_vars(theta_candidate = prior_grid_info$inputs_scaled[max_var_idx,], lpost_emulator_no_scale, theta_grid_integrate = prior_grid_info$inputs_scaled)

curr_post_log_var <- convert_to_post_emulator_log_moments(pred_grid_init_design$mean, pred_grid_init_design$var, "var")$var

plot(prior_grid_info$inputs, log_var2, col = "red", type = "l")
lines(prior_grid_info$inputs, log_var1, col = "blue")
lines(prior_grid_info$inputs, log_var3, col = "green")
lines(prior_grid_info$inputs, curr_post_log_var, col = "black")

points(prior_grid_info$inputs[1000,], 0, col = "red")
points(prior_grid_info$inputs[999,], 0, col = "blue")
points(prior_grid_info$inputs[max_var_idx,], 0, col = "green")

# TODO: need to explore conditioned GP plots. 
# Also add another line corresponding to third candidate that is not right next to the other two, somewhere more influential. 
# The difference is coming from the B term, need to investigate this. 

# TODO: there may be an issue with how I'm scaling lpost_emulator covariance. When I call predict_lpost_emulator() I specify to unscale, 
#       but then when I call calc_lpost_kernel() the scaling is still happening. NEED TO FIX. 
```

```{r}

lpost_emulator_cond_1 <- update_lpost_emulator(lpost_emulator_no_scale, inputs_new_scaled = prior_grid_info$inputs_scaled[999,,drop=FALSE])
lpost_emulator_cond_2 <- update_lpost_emulator(lpost_emulator_no_scale, inputs_new_scaled = prior_grid_info$inputs_scaled[1000,,drop=FALSE])

pred_cond_1 <- predict_lpost_emulator(prior_grid_info$inputs_scaled, lpost_emulator_cond_1)
pred_cond_2 <- predict_lpost_emulator(prior_grid_info$inputs_scaled, lpost_emulator_cond_2)

curr_post_log_var <- convert_to_post_emulator_log_moments(pred_grid_init_design$mean, pred_grid_init_design$var, "log_var")$log_var
post_cond_log_var_1 <- convert_to_post_emulator_log_moments(pred_cond_1$mean, pred_cond_1$var, "log_var")$log_var
post_cond_log_var_2 <- convert_to_post_emulator_log_moments(pred_cond_2$mean, pred_cond_2$var, "log_var")$log_var


plot(prior_grid_info$inputs, curr_post_log_var, col = "black", lty = 5, type = "l")
lines(prior_grid_info$inputs, post_cond_log_var_1, col = "blue")
lines(prior_grid_info$inputs, post_cond_log_var_2, col = "green")


```

```{r}

#
# Numerical validation. 
#

# Choose integration point u and candidate point u_tilde to investigate (both scaled).
u <- scale_input_data(matrix(-0.5, nrow = 1), input_bounds = lpost_emulator_no_scale$design_info_list$input_bounds)
u_tilde <- prior_grid_info$inputs_scaled[200,,drop=FALSE] # 600, 999

# Unconditioned log variance. 
un_lpost_pred <- predict_lpost_emulator(u, lpost_emulator_no_scale, uncenter = FALSE)
un_log_var <- convert_to_post_emulator_log_moments(un_lpost_pred$mean, un_lpost_pred$var)$log_var

# Closed-form log expected conditional variance. 
cond_log_var <- get_IVAR_post_vars(u_tilde, lpost_emulator_no_scale, u, verbose = TRUE) 

# New closed-form derivation of log expected conditional variance. 
lpost_emulator_no_scale_cond <- update_lpost_emulator(lpost_emulator_no_scale, inputs_new_scaled = u_tilde)
cond_lpost_pred <- predict_lpost_emulator(u, lpost_emulator_no_scale_cond, uncenter = FALSE)
log_var_KB <- convert_to_post_emulator_log_moments(cond_lpost_pred$mean, cond_lpost_pred$var, return_vals = "log_var")$log_var
un_lpost_pred_tilde <- predict_lpost_emulator(u_tilde, lpost_emulator_no_scale, return_vals = c("mean", "var", "cov"), 
                                              inputs_new_scaled_2 = u, uncenter = FALSE)

log_uncertainty_inflation_term <- 2 * drop(un_lpost_pred_tilde$cov)^2 / un_lpost_pred_tilde$var
cond_log_var_new_calc <- log_var_KB + log_uncertainty_inflation_term

# Log variance of conditional expectation.
cov_var_ratio <- drop(un_lpost_pred_tilde$cov)^2 / un_lpost_pred_tilde$var
log_var_cond_exp <- 2*cond_lpost_pred$mean + cond_lpost_pred$var + 2*cov_var_ratio # Note: using approx here; should do full log-sum-exp approx. 
total_variance_check <- matrixStats::logSumExp(c(cond_log_var_new_calc, log_var_cond_exp))
if(!all.equal(total_variance_check, un_log_var)) {
  message("Non-zero difference total variance calculation: ", total_variance_check - log_var_cond_exp)
}


# Monte Carlo Approximation of log expected conditional variance (i.e., estimate expected conditional variance, then take log of result). 
lpost_tilde_pred <- predict_lpost_emulator(u_tilde, lpost_emulator_no_scale, uncenter = FALSE)
log_pi_tilde_pred <- convert_to_post_emulator_log_moments(lpost_tilde_pred$mean, lpost_tilde_pred$var)
N_MC_test <- 1000000
lpost_tilde_samp <- rnorm(N_MC_test, lpost_tilde_pred$mean, sqrt(lpost_tilde_pred$var))

# Condition lpost emulator.  
lpost_emulator_no_scale_cond_MC <- update_lpost_emulator(lpost_emulator_no_scale, inputs_new_scaled = u_tilde)
np1 <- length(lpost_emulator_no_scale_cond_MC$outputs_lpost)

cond_lpost_mean_samp <- vector(mode = "numeric", length = N_MC_test)
cond_lpost_var_samp <- vector(mode = "numeric", length = N_MC_test)

for(j in seq_len(N_MC_test)) {
  
  # Update response. 
  lpost_emulator_no_scale_cond_MC$outputs_lpost[np1] <- lpost_tilde_samp[j]
  
  # Compute conditioned variance. 
  results <- predict_lpost_emulator(u, lpost_emulator_no_scale_cond_MC, uncenter = FALSE)
  cond_lpost_mean_samp[j] <- results$mean
  cond_lpost_var_samp[j] <- results$var # Note: this should be constant for all j, since pred var not function of response. 
  
}

cond_log_var_MC_samp <- convert_to_post_emulator_log_moments(cond_lpost_mean_samp, cond_lpost_var_samp)
cond_log_var_MC <- logSumExp(cond_log_var_MC_samp$log_var) - log(N_MC_test)

print(paste0("Log unconditioned post var: ", un_log_var))
print(paste0("Log Expected conditional post var (closed-form): ", cond_log_var))
print(paste0("Log Expected conditional post var (closed-form new calculation): ", cond_log_var_new_calc))
print(paste0("Log Expected conditional post var (MC Estimate): ", cond_log_var_MC))
print(paste0("Log Variance of conditional expectation: ", log_var_cond_exp))

range(cond_log_var_MC_samp$log_var) # Entire range is less than un_log_var, as it should be. 


# Conclusions: 
#    - Closed-form expected conditional variance calculation is wrong. Investigate `get_IVAR_post_vars()`. 
#    - It appears that the issue is coming from the B vector / "uncertainty term". Need to check this. 


```

```{r}
# Monte Carlo Approximations. 

# Choose integration point u and candidate point u_tilde to investigate (both scaled).
u <- scale_input_data(matrix(-0.5, nrow = 1), input_bounds = lpost_emulator_no_scale$design_info_list$input_bounds)
u_tilde <- prior_grid_info$inputs_scaled[200,,drop=FALSE] # 600, 999

# Unconditioned log moments  
un_lpost_pred <- predict_lpost_emulator(u, lpost_emulator_no_scale, uncenter = FALSE)
un_post_pred <- convert_to_post_emulator_log_moments(un_lpost_pred$mean, un_lpost_pred$var)











```

















```{r}
# Testing predictive covariance code. 
# TODO: add this to more structured validation code. 
pred1 <- predict_lpost_GP_approx(theta_vals_scaled = u, emulator_info_list = lpost_emulator_no_scale$emulator_info_list, 
                                 sig2_eps = lpost_emulator_no_scale$sig2_eps, theta_prior_params = theta_prior_params, 
                                 N_obs = computer_model_data$n_obs, theta_vals_scaled_2 = u_tilde, return_vals = c("mean", "var", "cov"))

pred2 <- predict_lpost_emulator(inputs_new_scaled = u, lpost_emulator = lpost_emulator_no_scale, return_vals = c("mean", "var", "cov"), 
                                inputs_new_scaled_2 = u_tilde, uncenter = TRUE)

print("Means")
print(paste0("predict_lpost_GP_approx: ", pred1$mean))
print(paste0("predict_lpost_emulator: ", pred2$mean))

print("Vars")
print(paste0("predict_lpost_GP_approx: ", pred1$var))
print(paste0("predict_lpost_emulator: ", pred2$var))

print("Cov")
print(paste0("predict_lpost_GP_approx: ", pred1$cov))
print(paste0("predict_lpost_emulator: ", pred2$cov))

```









```{r}
# IVAR-post debugging: exploring evaluation at design point vs. point right next to design point. 
test <- acquisition_IVAR_post(theta_vals = prior_grid_info$inputs_scaled[c(999, 1000),,drop=FALSE], lpost_emulator = lpost_emulator, 
                              theta_grid_integrate = prior_grid_info$inputs_scaled, 
                              include_nugget = TRUE)


```







# Computer Model and Data 

```{r, include = FALSE}
# Synthetic data generation
computer_model_data <- generate_vsem_test_case(4)
```

```{r, echo = FALSE}
print(computer_model_data$ref_pars[computer_model_data$pars_cal_sel,])
```

```{r echo = FALSE}
for(output_var in computer_model_data$output_vars) {
 plotTimeSeries(observed = computer_model_data$data_obs[, output_var],
                predicted = computer_model_data$data_ref[, output_var], main = output_var) 
}
```

# Priors 

## Calibration Parameters 
```{r, echo = FALSE} 
# Priors 
theta_prior_params <- computer_model_data$ref_pars[computer_model_data$pars_cal_sel,]
theta_prior_params[, "dist"] <- c("Uniform", "Uniform")
theta_prior_params[,"param1"] <- c(1.3, 0.4) # theta_prior_params[,"lower"]
theta_prior_params[,"param2"] <- c(1.7, 0.6)  # theta_prior_params[,"upper"]
theta_prior_params <- theta_prior_params[, c("dist", "param1", "param2")]

print("Calibration parameter prior:")
print(theta_prior_params)
```


## Likelihood Parameters 
```{r, echo = FALSE}
sig2_prior_info <- get_IG_priors_numerical_test(sig2_true = diag(computer_model_data$Sig_eps), 
                                                bias_frac = c(0.1, -0.15), bins = 50,
                                                coef_var = c(0.3, 0.5), return_prior_plots = TRUE, 
                                                output_variables = computer_model_data$output_vars)
sig_eps_prior_params <- sig2_prior_info$prior
plts <- sig2_prior_info$plots

print("Priors on variance parameters:")
grid.arrange(arrangeGrob(grobs = plts, nrow = 1))
```

# Exact MCMC Samples.

## Exact MCMC. 
```{r, echo = FALSE}
N_mcmc_exact <- 50000

time_start <- proc.time()
mcmc_exact_list <- mcmc_calibrate_product_lik(computer_model_data = computer_model_data, 
                                              theta_prior_params = theta_prior_params, 
                                              learn_sig_eps = TRUE,
                                              sig_eps_prior_params = sig_eps_prior_params,
                                              N_mcmc = N_mcmc_exact)
mcmc_exact_runtime <- (proc.time() - time_start)[["elapsed"]]
print(paste0("Exact MCMC runtime: ", mcmc_exact_runtime, " seconds."))

# Format MCMC samples. 
mcmc_samp_dt <- format_mcmc_output(samp_list = mcmc_exact_list[c("theta", "sig_eps")], test_label = "exact")

```

```{r, echo = FALSE}
burn_ins <- c(exact = 10000)

mcmc_exact_trace_plts <- get_trace_plots(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "exact", param_types = "theta")
grid.arrange(arrangeGrob(grobs = mcmc_exact_trace_plts, nrow = 1))
```

```{r, echo = FALSE}
mcmc_exact_trace_plts_sig_eps <- get_trace_plots(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "exact", param_types = "sig_eps")
grid.arrange(arrangeGrob(grobs = mcmc_exact_trace_plts_sig_eps, nrow = 1))
```

```{r, echo = FALSE}
# Store matrix of calibration parameter samples from exact MCMC for plotting purposes. 
samp_exact_theta <- select_mcmc_samp(mcmc_samp_dt, burn_in_start = burn_ins, test_labels = "exact", param_types = "theta")[, .(param_name, sample)]
samp_exact_theta <- as.matrix(unstack(samp_exact_theta, sample ~ param_name))[, computer_model_data$pars_cal_names]
```


# Setup for Design Initialization. 

```{r, echo = FALSE}
# Emulator settings
emulator_settings <- data.frame(gp_lib = c("hetGP"), 
                                kernel = "Gaussian", 
                                transformation_method = c("truncated"),
                                emulator_target = "SSR",
                                scale_X = TRUE, 
                                normalize_y = TRUE)

print("Emulator Settings:")
print(emulator_settings)
```

```{r, echo = FALSE}

# Design settings.
design_settings <- data.frame(N_design = 15, design_method = "LHS")
design_seed <- 5
set.seed(design_seed)

# Input bounds that will be used to scale all designs. 
input_bounds <- t(as.matrix(theta_prior_params[, c("param1", "param2")]))
rownames(input_bounds) <- c("min", "max")

print("Design Settings:")
print(design_settings)
```

```{r, include = FALSE}
# Prior grid over which acquisitions will be evaluated. Also will be used for plotting. 

prior_grid_info <- get_input_output_design(N_points = 51^2,
                                           design_method = "grid", 
                                           scale_inputs = TRUE,
                                           param_ranges = input_bounds,
                                           computer_model_data = computer_model_data, 
                                           theta_prior_params = theta_prior_params)

lpost_true_grid <- calc_lpost_theta_product_lik(computer_model_data = computer_model_data, 
                                                theta_vals = prior_grid_info$inputs, 
                                                vars_obs = diag(computer_model_data$Sig_eps), 
                                                SSR = prior_grid_info$outputs,
                                                na.rm = TRUE, theta_prior_params = theta_prior_params, 
                                                return_list = FALSE)

# Index selectors for candidate and integration points. 
theta_grid_candidate_sel <- seq_len(nrow(prior_grid_info$inputs_scaled))
theta_grid_integrate_sel <- seq_len(nrow(prior_grid_info$inputs_scaled))

```


```{r, echo = FALSE}

# True posterior heatmap plot. 
true_post_plot <- get_2d_response_surface_plot(computer_model_data = computer_model_data, 
                                               theta_vals = prior_grid_info$inputs, 
                                               param_names = computer_model_data$pars_cal_names, 
                                               response_surface = "posterior", 
                                               output_variables = computer_model_data$output_vars, 
                                               raster = TRUE, point_coords = computer_model_data$theta_true, 
                                               samples_kde = samp_exact_theta, lpost_vals = lpost_true_grid)

plot(true_post_plot)
```


# IVAR acquisition evaluations on different initial designs.  

```{r, include = FALSE}

N_design_tests <- 1
design_list <- vector(mode = "list", length = N_design_tests)
lpost_emulator_list <- vector(mode = "list", length = N_design_tests)
pred_list <- vector(mode = "list", length = N_design_tests)
plt_list <- vector(mode = "list", length = N_design_tests)

for(design_itr in seq_len(N_design_tests)) {

  # Generate initial design.
  init_design <- get_input_output_design(N_points = design_settings$N_design, 
                                         computer_model_data = computer_model_data, 
                                         theta_prior_params = theta_prior_params, 
                                         param_ranges = input_bounds,
                                         scale_inputs = TRUE, 
                                         normalize_response = TRUE, 
                                         design_method = design_settings$design_method, 
                                         na.rm = TRUE)
  init_design$input_bounds <- input_bounds
  init_estimates <- get_init_param_estimates(init_design, computer_model_data, sig_eps_prior_params, verbose = FALSE)
  init_design$init_estimates <- init_estimates
  design_list[[design_itr]] <- init_design
  
  # Fit GP on initial design. 
  gp_fits <- fit_independent_GPs(X_train = init_design$inputs_scaled, Y_train = init_design$outputs_normalized, 
                                 gp_lib = emulator_settings$gp_lib, gp_kernel = emulator_settings$kernel)$fits
  emulator_info_list <- list(gp_fits = gp_fits, input_bounds = input_bounds, 
                             output_stats = init_design$output_stats, settings = emulator_settings)
  lpost_emulator <- get_lpost_emulator_obj(emulator_info_list = emulator_info_list, design_info_list = init_design, 
                                           computer_model_data = computer_model_data, sig2_eps = init_design$init_estimates$best_sig2_eps, 
                                           theta_prior_params = theta_prior_params)

  # Generate lpost predictive plots. 
  lpost_emulator_pred<- predict_lpost_emulator(lpost_emulator = lpost_emulator, 
                                               inputs_new_scaled = prior_grid_info$inputs_scaled, 
                                               inputs_new_unscaled = prior_grid_info$inputs, include_nugget = TRUE)
  pred_list[[design_itr]] <- list()
  pred_list[[design_itr]]$lpost_emulator_pred <- lpost_emulator_pred
  
  # Produce IVAR-post and IVAR-lpost evaluations. 
  IVAR_lpost_vals <- acquisition_EIVAR_lpost(theta_vals = prior_grid_info$inputs_scaled[theta_grid_candidate_sel,], 
                                             lpost_emulator = lpost_emulator, 
                                             theta_grid_integrate = prior_grid_info$inputs_scaled[theta_grid_integrate_sel,], 
                                             verbose = FALSE, include_nugget = TRUE)
  IVAR_post_vals <- acquisition_IVAR_post(theta_vals = prior_grid_info$inputs_scaled[theta_grid_candidate_sel,], 
                                          lpost_emulator = lpost_emulator, 
                                          theta_grid_integrate = prior_grid_info$inputs_scaled[theta_grid_integrate_sel,], 
                                          verbose = FALSE, include_nugget = TRUE)
  pred_list[[design_itr]]$IVAR_lpost <- IVAR_lpost_vals
  pred_list[[design_itr]]$IVAR_post <- IVAR_post_vals
  
  
  # Produce plots. 
  plt_list[[design_itr]] <- list(scatter = list(), heatmap = list(), lpost_pred = list())
  plt_list[[design_itr]]$lpost_pred$mean <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                                                y = lpost_emulator_pred$mean, param_names = computer_model_data$pars_cal_names, 
                                                                samples_kde = samp_exact_theta, raster = TRUE, 
                                                                samples_points = init_design$inputs, 
                                                                point_coords = computer_model_data$theta_true, bigger_is_better = TRUE, 
                                                                main_title = "lpost predictive mean")
  plt_list[[design_itr]]$lpost_pred$var <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                                               y = lpost_emulator_pred$var, param_names = computer_model_data$pars_cal_names, 
                                                               samples_kde = samp_exact_theta, raster = TRUE, 
                                                               samples_points = init_design$inputs, log_scale = TRUE, 
                                                               point_coords = computer_model_data$theta_true, bigger_is_better = TRUE, 
                                                               main_title = "lpost predictive var")

  plt_list[[design_itr]]$heatmap$IVAR_lpost <- get_2d_heatmap_plot(X = prior_grid_info$inputs[theta_grid_candidate_sel,], 
                                                                   y = IVAR_lpost_vals, param_names = computer_model_data$pars_cal_names, 
                                                                   samples_kde = samp_exact_theta, raster = TRUE, 
                                                                   samples_points = init_design$inputs, 
                                                                   point_coords = computer_model_data$theta_true, bigger_is_better = TRUE, 
                                                                   main_title = "IVAR-lpost")
  plt_list[[design_itr]]$heatmap$IVAR_post <- get_2d_heatmap_plot(X = prior_grid_info$inputs[theta_grid_candidate_sel,], 
                                                                  y = IVAR_post_vals, param_names = computer_model_data$pars_cal_names, 
                                                                  samples_kde = samp_exact_theta, raster = TRUE, 
                                                                  samples_points = init_design$inputs, 
                                                                  point_coords = computer_model_data$theta_true, bigger_is_better = TRUE, 
                                                                  main_title = "log IVAR-post")
  plt_list[[design_itr]]$scatter$IVAR_lpost$mean <- plot(x = lpost_emulator_pred$mean[theta_grid_candidate_sel], 
                                                         y = IVAR_lpost_vals, 
                                                         xlab = "lpost pred mean", ylab = "IVAR-lpost", main = "Predictive Mean vs. Acquisition")
  plt_list[[design_itr]]$scatter$IVAR_post$mean <- plot(x = lpost_emulator_pred$mean[theta_grid_candidate_sel], 
                                                        y = IVAR_post_vals, 
                                                        xlab = "lpost pred mean", ylab = "log IVAR-post", main = "Predictive Mean vs. Acquisition")
  plt_list[[design_itr]]$scatter$IVAR_lpost$var <- plot(x = lpost_emulator_pred$var[theta_grid_candidate_sel], 
                                                        y = IVAR_lpost_vals, 
                                                        xlab = "lpost pred var", ylab = "IVAR-lpost", main = "Predictive Var vs. Acquisition")
  plt_list[[design_itr]]$scatter$IVAR_post$var <- plot(x = lpost_emulator_pred$var[theta_grid_candidate_sel], 
                                                       y = IVAR_post_vals, 
                                                       xlab = "lpost pred var", ylab = "log IVAR-post", main = "Predictive Var vs. Acquisition")
  
  
}

```


```{r}
# Compare true log posterior density to lpost emulator. 
plot(true_post_plot)
plot(plt_list[[1]]$lpost_pred$mean)
plot(plt_list[[1]]$lpost_pred$var)
```

```{r}
# Compare true log posterior density to log of post emulator moments. 

mu <- pred_list[[1]]$lpost_emulator_pred$mean
sig2 <- pred_list[[1]]$lpost_emulator_pred$var

log_post_mean <- mu + 0.5 * sig2

idx_approx_sel <- (sig2 >= 100)
log_exp_term <- vector(mode = "numeric", length = length(sig2))
log_exp_term[!idx_approx_sel] <- log(exp(sig2[!idx_approx_sel]) - 1)
log_exp_term[idx_approx_sel] <- sig2[idx_approx_sel] # Apply approximation. 

log_post_var <- 2*mu + sig2 + log_exp_term 


post_mean_plot <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                      y = log_post_mean - min(log_post_mean) + 1 , param_names = computer_model_data$pars_cal_names, 
                                      samples_kde = samp_exact_theta, raster = TRUE, 
                                      samples_points = init_design$inputs, log_scale = TRUE, 
                                      point_coords = computer_model_data$theta_true, bigger_is_better = TRUE, 
                                      main_title = "log of post predictive mean")
post_var_plot <- get_2d_heatmap_plot(X = prior_grid_info$inputs, 
                                     y = log_post_var - min(log_post_var) + 1, param_names = computer_model_data$pars_cal_names, 
                                     samples_kde = samp_exact_theta, raster = TRUE, 
                                     samples_points = init_design$inputs, log_scale = TRUE,
                                     point_coords = computer_model_data$theta_true, bigger_is_better = TRUE, 
                                     main_title = "log of post predictive var")

plot(true_post_plot)
plot(post_mean_plot)
plot(post_var_plot)
```


```{r}
plot(plt_list[[design_itr]]$heatmap$IVAR_lpost)
plot(plt_list[[design_itr]]$heatmap$IVAR_post)
```






```{r}
# TODO: need to compare to predictive mean and variance of lpost_emulator. 
# TODO: also, compare predictive mean and (log) variance of post_emulator to that of lpost_emulator. 
# TODO: scatterplots comparing the acquisitions to the lpost emulator predictive mean and variance. 
plot(plt_list[[1]]$IVAR_lpost)
plot(plt_list[[1]]$IVAR_post)
```










