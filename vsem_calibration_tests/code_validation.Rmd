---
title: "Code Validation"
author: "Andrew Roberts"
date: '2023-04-08'
output: html_document
---

```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(lhs)
library(hetGP)
library(mlegp)
library(ggplot2)
library(gridExtra)
library(data.table)
library(BayesianTools)

source("mcmc_calibration_functions.r")
source("gp_emulator_functions.r")
```

# This document contains code validation for emulator/calibration related functions. 

## Testing GP Transformation Functions
#### Comparing Rectified Gaussian moment calculations with sample estimates. 
```{r}
Gaussian_means <- c(0, -.5)
Gaussian_vars <- c(1, 2)

# Compute means and variances
moments <- transform_GP_to_rectified_GP(Gaussian_means, Gaussian_vars)

# Monte Carlo approximation of means and variances
N_samp <- 10000000
samp <- matrix(nrow = N_samp, ncol = length(Gaussian_means))
for(j in seq_along(Gaussian_means)) {
  samp[,j] <- pmax(rnorm(N_samp, mean = Gaussian_means[j], sd = sqrt(Gaussian_vars[j])), 0)
}
sample_means <- colMeans(samp)
sample_vars <- colMeans(samp^2) - sample_means^2

print("Means computed:")
print(moments$mean)

print("Sample means:")
print(sample_means)

print("Variances:")
print(moments$var)

print("Sample vars:")
print(sample_vars)

```
#### Comparing two different functions that compute truncated Gaussian moments. 
```{r}
print("Method 1:")
print(transform_GP_to_truncated_GP(Gaussian_means, Gaussian_vars))

print("Method 2:")
print(compute_zero_truncated_Gaussian_moments(Gaussian_means, Gaussian_vars))
```
#### Validating quantile function for rectified Gaussian distribution using simulation. 
```{r}
p_vals <- seq(0.1, 1.0, by = 0.1)

# Sample quantiles.
print("Sample Quantiles:")
for(j in seq(1, ncol(samp))) {
  print(quantile(samp[,j], p_vals))
}

# Computed quantiles.
print("Computed Quantiles:")
computed_quantiles <- sapply(p_vals, function(p) quantile_rectified_norm(p, mean = Gaussian_means, sd = sqrt(Gaussian_vars)))
print(computed_quantiles)
```

# One-Dimensional GP Tests
```{r}

# Training and testing input data. 
prior_params <- data.frame(dist = "Uniform", param1 = -10, param2 = 10)
train_data <- get_input_design(12, prior_params, "LHS", scale_inputs = TRUE, order_1d = TRUE)
test_data <- get_input_design(151, prior_params, "grid", scale_inputs = TRUE, param_ranges = train_data$input_bounds)

# Latent function; producing training and testing response data. 
f <- function(x) cos(x) + sin(x)
train_data$outputs <- f(train_data$inputs)
test_data$outputs <- f(test_data$inputs)
train_data[c("outputs_normalized", "output_stats")] <- prep_GP_training_data(Y = train_data$outputs, normalize_Y = TRUE)[c("Y", "output_stats")]
test_data[["outputs_normalized"]] <- normalize_output_data(test_data$outputs, output_stats = train_data$output_stats)

# Fit GP. 
gp <- fit_GP(train_data$inputs_scaled, train_data$outputs_normalized, "mlegp", "Gaussian")$fit

# Predict at test locations. 
gp_pred <- predict_GP(test_data$inputs_scaled, gp, "mlegp", denormalize_predictions = TRUE, output_stats = train_data$output_stats) 
           
# Plot GP.
gp_plot <- plot_gp_fit_1d(test_data$inputs, test_data$outputs, train_data$inputs, train_data$outputs, gp_pred$mean, gp_pred$var,
                          xlab = "X", ylab = "Y", main_title = "GP Plot", CI_prob = 0.9)
print(gp_plot)
```






