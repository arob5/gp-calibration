---
title: "GP-Accelerated MCMC Comparison"
author: "Andrew Roberts"
date: '2023-10-30'
output: html_document
---

```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(lhs)
library(hetGP)
library(mlegp)
library(ggplot2)
library(viridis)
library(parallel)
library(gridExtra)
library(data.table)
library(BayesianTools)

source("numerical_experiment_functions.r")
source("mcmc_calibration_functions.r")
source("gp_emulator_functions.r")
source("gp_mcmc_functions.r")
source("sequential_design_optimization.r")
source("sequential_design_sim_study.r")
```

# 1D Linear Gaussian Model 

We begin we the simplest possible example, the one-dimensional linear Gaussian model 
$$
\begin{align*}
\mathbf{y} &= \mathbf{g}u + \epsilon \\
\epsilon &\sim \mathcal{N}(0, \sigma_\epsilon^2) \\
u &\sim \mathcal{N}(\mu_0, \sigma^2_0),
\end{align*}
$$
where $\mathbf{g}, \mathbf{y} \in \mathbb{R}^T$ and the noise variance $\sigma_\epsilon^2$ is assumed to be known. This results in an unnormalized log posterior density 
$$
\ell^\pi(u) \propto -\frac{1}{2} \log(2\pi\sigma_{\epsilon}^2) - \frac{\Phi(u)}{2\sigma^2_\epsilon} - \frac{1}{2\sigma^2_0}(u - \mu_0)^2,
$$
where 
$$
\Phi(u) := ||\mathbf{y} - \mathbf{g}u||_2^2
$$
is the data-misfit.


```{r}
# Linear Gaussian Model Setup. 
N_obs <- 100
freq <- 1
g <- matrix(sin(2*pi*freq*seq(1, N_obs)/N_obs), ncol=1)
sig2_eps <- 1
sig2_0 <- matrix(1)
mu0 <- 0

# linear_Gaussian_info <- generate_linear_Gaussian_test_data(linear_Gaussian_seed, N_obs=N_obs, 
#                                                            D=1, Sig_theta=sig2_0, G=g, sig2_eps=sig2_eps)
# computer_model_data <- linear_Gaussian_info$computer_model_data
# theta_prior_params <- linear_Gaussian_info$theta_prior_params
# linear_Gaussian_info$true_posterior$SSR <- get_computer_model_SSR(computer_model_data, 
#                                                                   theta_vals=linear_Gaussian_info$true_posterior$mean, 
#                                                                   na.rm=TRUE)
# 
# plot(1:N_obs, computer_model_data$data_obs, main = "Ground Truth and Observed Data", xlab = "t")
# lines(1:N_obs, computer_model_data$data_ref, col = "red")
```


```{r}

#
# Observational Data, Forward Model, and Emulator Setup. 
#

# Random number generator seeds.
data_seed <- 5
design_seed <- 10

# Defining forward model.
freq <- 1
g <- matrix(sin(2*pi*freq*seq(1, N_obs)/N_obs), ncol=1)

# Likelihood parameters and priors. 
sig2_eps <- 1
sig2_0 <- matrix(1)
N_obs <- 100

# Emulator settings. 
N_design <- 4
emulator_settings <- data.frame(gp_lib = c("hetGP"), 
                                kernel = "Gaussian", 
                                transformation_method = c("truncated"),
                                emulator_target = "SSR",
                                scale_X = TRUE, 
                                normalize_y = TRUE)

# Generate data and fit emulator. 
linear_Gaussian_list <- get_1d_linear_Gaussian_approx_post_density(data_seed, design_seed, g, sig2_eps, sig2_0, N_design,
                                                                   emulator_settings, N_obs, design_method="grid")
computer_model_data <- linear_Gaussian_list$obj$computer_model_data
lpost_emulator <- linear_Gaussian_list$obj$lpost_emulator
linear_Gaussian_info <- linear_Gaussian_list$obj$linear_Gaussian_info

for(plt in linear_Gaussian_list$plots) plot(plt)
```

```{r}
#
# MCMC Setup. 
#

# Emulator-Accelerated MCMC algorithms. 
mcmc_algs <- c("ind_gp_gibbs", "ind_gp_trajectory")

mcmc_info_list <- run_gp_mcmc_tests(computer_model_data, lpost_emulator, mcmc_algs, N_chain=4, N_itr=50000, 
                                    learn_sig_eps=FALSE, return_cov_prop_scale=TRUE, return_SSR_samp=TRUE, 
                                    burn_ins=1)
mcmc_samp_dt <- mcmc_info_list$mcmc_samp_dt
burn_ins <- mcmc_info_list$burn_ins

# Append samples from exact posterior. 
N_samp_exact <- 25000
samp_exact <- rnorm(n=N_samp_exact, mean=drop(linear_Gaussian_info$true_posterior$mean), 
                    sd=sqrt(drop(linear_Gaussian_info$true_posterior$Cov)))
samp_exact_dt <- data.table(param_type="theta", 
                            itr=seq_len(N_samp_exact), 
                            param_name=computer_model_data$pars_cal_names, 
                            sample=samp_exact,
                            test_label="exact")
mcmc_samp_dt <- rbindlist(list(mcmc_samp_dt, samp_exact_dt), use.names=TRUE)

```

```{r}
trace_plots <- get_trace_plots(mcmc_samp_dt)
for(plt in trace_plots) plot(plt)
```

```{r}
# TODO: 
#    1.) look into why the trajectory alg posterior is multimodal, while the current PEcAn alg is not. 
#    2.) look into adding second Phi sampling step in the trajectory algorithm. 
#    3.) return effective proposal variances (scale parameter times diag of proposal covariance) in mcmc_samp_dt. 
#    4.) add option to exclude a param_type when selecting columns. 
#    5.) Re-check math for the Gibbs alg.
#    6.) Try out alternative proposal for Gibbs alg. 
#    7.) Implement the marg algorithm to compare. 

hist_plots <- get_hist_plot_comparisons(mcmc_samp_dt, test_label_baseline="exact", xlab="samples", ylab="density",
                                        bins=30)
for(plt in hist_plots) plot(plt)
```

