---
title: "Higher Dimensional GP-Accelerated MCMC Comparison"
author: "Andrew Roberts"
date: '2023-12-19'
output: html_document
---


```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(lhs)
library(hetGP)
library(mlegp)
library(ggplot2)
library(viridis)
library(parallel)
library(gridExtra)
library(data.table)
library(BayesianTools)

source("numerical_experiment_functions.r")
source("mcmc_calibration_functions.r")
source("gp_emulator_functions.r")
source("gp_mcmc_functions.r")
source("sequential_design_optimization.r")
source("sequential_design_sim_study.r")
```


```{r}
# TODOs: 
#    - Write plotting functions suitable for evaluating GP emulators with multivariate input space. Maybe plot y vs. y_hat. 
#    - Update linear Gaussian data generation function: clean up code, improve comments, and allow for non-zero mean Gaussian prior. 
```


```{r}
seed <- 23
```


```{r}
# Linear Gaussian Model Setup. 
N_obs <- 100
D <- 6
freqs <- c(0.1, 1, 1.4, 2, 0.5, 1.1)
G <- matrix(nrow=N_obs, ncol=D)
for(d in 1:D) {
  G[,d] <- matrix(sin(2*pi*freqs[d]*seq(1, N_obs)/N_obs), ncol=1)
}

sig2_eps <- 1
Sig0 <- diag(rlnorm(D, meanlog=0, sdlog=2))
mu0 <- rnorm(D, mean=0, sd=4)

# Get synthetic data. 
linear_Gaussian_info <- generate_linear_Gaussian_test_data(seed, N_obs, D, Sig0, G, sig2_eps=sig2_eps)
computer_model_data <- linear_Gaussian_info$computer_model_data
theta_prior_params <- linear_Gaussian_info$theta_prior_params

plot(1:N_obs, computer_model_data$data_obs, main="Ground Truth and Observed Data", 
     xlab="t", ylab="y")
lines(1:N_obs, computer_model_data$data_ref, col="red")

```

```{r}

#
# Emulator Setup. 
#

# Emulator settings. 
N_design <- 100
design_method <- "LHS"
emulator_settings <- data.frame(gp_lib = c("hetGP"), 
                                kernel = "Gaussian", 
                                transformation_method = c("truncated"),
                                emulator_target = "SSR",
                                scale_X = TRUE, 
                                normalize_y = TRUE)

# Generate design. 
input_bounds <- matrix(c(min=qnorm(.01, theta_prior_params$param1, theta_prior_params$param2), 
                         max=qnorm(.99, theta_prior_params$param1, theta_prior_params$param2)), ncol=D)
rownames(input_bounds) <- c("min", "max")
colnames(input_bounds) <- computer_model_data$pars_cal_names
theta_prior_params_trunc <- truncate_prior_theta(theta_prior_params, input_bounds)

# Initial Design. 
design_settings <- data.frame(N_design=N_design, design_method=design_method)
init_design_info <- get_input_output_design(N_points=design_settings$N_design,
                                            design_method=design_settings$design_method, 
                                            scale_inputs=TRUE,
                                            param_ranges=input_bounds,  
                                            computer_model_data=computer_model_data, 
                                            theta_prior_params=theta_prior_params)
init_design_info$lpost <- calc_lpost_theta_product_lik(computer_model_data=computer_model_data, 
                                                       theta_vals=init_design_info$inputs, 
                                                       vars_obs=sig2_eps, 
                                                       SSR=init_design_info$outputs,
                                                       na.rm=TRUE, theta_prior_params=theta_prior_params, 
                                                       return_list=FALSE)
  
# Fit emulators on initial design. 
gp_fits <- fit_independent_GPs(X_train=init_design_info$inputs_scaled, Y_train=init_design_info$outputs_normalized, 
                               gp_lib=emulator_settings$gp_lib, gp_kernel=emulator_settings$kernel)$fits
emulator_info_list <- list(gp_fits=gp_fits, input_bounds=init_design_info$input_bounds, 
                           output_stats=init_design_info$output_stats, settings=emulator_settings)

for(fit in gp_fits) plot(fit)
```

```{r}
# Prepare GP-MCMC tests. 

# General settings to apply to all runs. 
N_mcmc <- 50000
learn_sig_eps <- FALSE
sig2_eps_init <- sig2_eps

# Fix pre-MCMC estimates of calibration and likelihood parameters based on design data. All MCMC
# algs will use this initialization. 
best_idx <- which.max(init_design_info$lpost)
theta_init <- init_design_info$inputs[best_idx,]

# Initialize proposal covariance using design. 
cov_prop_init_diag <- diag(cov(init_design_info$inputs))

# Algorithm-specific settings list. 
run_settings_list <- list()
# run_settings_list[["gibbs_adapt_cov"]] <- list(test_label="gibbs_adapt_cov", 
#                                                alg="ind_gp_gibbs",
#                                                adapt_cov=TRUE, 
#                                                adapt_scale=FALSE)
run_settings_list[["gibbs_traj"]] <- list(test_label="gibbs_traj", 
                                          alg="ind_gp_trajectory",
                                          adapt_cov=TRUE, 
                                          adapt_scale=TRUE,
                                          use_gp_cov=TRUE, 
                                          second_gibbs_step=FALSE, 
                                          Cov_prop_init_diag=NULL)
```


```{r}
# Run GP-MCMC algorithms. 
mcmc_test_info <- run_gp_mcmc_tests(run_settings_list, computer_model_data=computer_model_data, 
                                    theta_prior_params=theta_prior_params_trunc,
                                    emulator_info_list=emulator_info_list, theta_init=theta_init,
                                    N_chain=4, N_itr=N_mcmc, burn_ins=NULL, learn_sig_eps=FALSE,
                                    return_cov_prop_scale=TRUE, return_SSR_samp=TRUE, sig2_eps_init=sig2_eps, 
                                    cov_prop_init_diag=cov_prop_init_diag)
mcmc_samp_dt <- mcmc_test_info$mcmc_samp_dt
burn_ins <- mcmc_test_info$burn_ins
```










